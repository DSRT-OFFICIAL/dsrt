<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Cube with Orbit Controls</title>
  <style>
    body { margin: 0; background: black; }
    canvas { width: 100vw; height: 100vh; display: block; cursor: grab; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}
function createProgram(gl, vsSource, fsSource) {
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  return program;
}

const canvas = document.getElementById("glcanvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext("webgl");
gl.enable(gl.DEPTH_TEST);

// Shaders
const vsSource = `
  attribute vec3 aPosition;
  uniform mat4 uModel;
  uniform mat4 uView;
  uniform mat4 uProjection;
  void main() {
    gl_Position = uProjection * uView * uModel * vec4(aPosition, 1.0);
  }
`;
const fsSource = `
  precision mediump float;
  uniform vec3 uColor;
  void main() {
    gl_FragColor = vec4(uColor, 1.0);
  }
`;
const program = createProgram(gl, vsSource, fsSource);
gl.useProgram(program);

// Cube vertices + indices
const vertices = new Float32Array([
  -0.5,-0.5, 0.5,  0.5,-0.5, 0.5,  0.5, 0.5, 0.5, -0.5, 0.5, 0.5,
  -0.5,-0.5,-0.5,  0.5,-0.5,-0.5,  0.5, 0.5,-0.5, -0.5, 0.5,-0.5,
]);
const indices = new Uint16Array([
  0,1,2, 2,3,0,
  4,5,6, 6,7,4,
  0,4,7, 7,3,0,
  1,5,6, 6,2,1,
  3,2,6, 6,7,3,
  0,1,5, 5,4,0
]);

// Buffers
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
const ibo = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

const aPosition = gl.getAttribLocation(program, "aPosition");
gl.enableVertexAttribArray(aPosition);
gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

const uModel = gl.getUniformLocation(program, "uModel");
const uView = gl.getUniformLocation(program, "uView");
const uProjection = gl.getUniformLocation(program, "uProjection");
const uColor = gl.getUniformLocation(program, "uColor");

// Matrix utils
function perspective(fov, aspect, near, far) {
  const f = 1.0 / Math.tan(fov / 2);
  return new Float32Array([
    f/aspect,0,0,0,
    0,f,0,0,
    0,0,(far+near)/(near-far),-1,
    0,0,(2*far*near)/(near-far),0
  ]);
}
function identity(){return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);}
function multiply(a,b){const o=new Float32Array(16);for(let i=0;i<4;i++){for(let j=0;j<4;j++){o[j*4+i]=a[i]*b[j*4]+a[i+4]*b[j*4+1]+a[i+8]*b[j*4+2]+a[i+12]*b[j*4+3];}}return o;}
function translate(x,y,z){return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1]);}
function rotateY(a){const c=Math.cos(a),s=Math.sin(a);return new Float32Array([c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1]);}
function rotateX(a){const c=Math.cos(a),s=Math.sin(a);return new Float32Array([1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1]);}

// Projection
const projection = perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 100);

// Orbit camera state
let camAngleX = 0.8, camAngleY = 0.8, camDistance = 3;
let dragging = false, lastX=0, lastY=0;

canvas.addEventListener("mousedown", e=>{dragging=true;lastX=e.clientX;lastY=e.clientY;});
canvas.addEventListener("mouseup", ()=>dragging=false);
canvas.addEventListener("mousemove", e=>{
  if(dragging){
    camAngleY += (e.clientX-lastX)*0.01;
    camAngleX += (e.clientY-lastY)*0.01;
    lastX=e.clientX; lastY=e.clientY;
  }
});
canvas.addEventListener("wheel", e=>{
  camDistance += e.deltaY*0.01;
  if(camDistance<1) camDistance=1;
});

// Touch controls
let touchStartX=0,touchStartY=0;
canvas.addEventListener("touchstart", e=>{
  if(e.touches.length===1){
    touchStartX=e.touches[0].clientX;
    touchStartY=e.touches[0].clientY;
  }
});
canvas.addEventListener("touchmove", e=>{
  if(e.touches.length===1){
    camAngleY += (e.touches[0].clientX-touchStartX)*0.01;
    camAngleX += (e.touches[0].clientY-touchStartY)*0.01;
    touchStartX=e.touches[0].clientX;
    touchStartY=e.touches[0].clientY;
  }
});

// Animation
function animate() {
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  const model = multiply(rotateY(Date.now()*0.001), rotateX(Date.now()*0.0007));

  // Camera orbit
  const eyeX = camDistance*Math.sin(camAngleY)*Math.cos(camAngleX);
  const eyeY = camDistance*Math.sin(camAngleX);
  const eyeZ = camDistance*Math.cos(camAngleY)*Math.cos(camAngleX);
  const view = lookAt([eyeX,eyeY,eyeZ],[0,0,0],[0,1,0]);

  gl.uniformMatrix4fv(uModel,false,model);
  gl.uniformMatrix4fv(uView,false,view);
  gl.uniformMatrix4fv(uProjection,false,projection);
  gl.uniform3fv(uColor,[0.2,0.7,1.0]);

  gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
  requestAnimationFrame(animate);
}
animate();

// LookAt matrix
function lookAt(eye,center,up){
  const [ex,ey,ez]=eye,[cx,cy,cz]=center,[ux,uy,uz]=up;
  let zx=ex-cx,zy=ey-cy,zz=ez-cz;
  const zn=1/Math.hypot(zx,zy,zz); zx*=zn;zy*=zn;zz*=zn;
  let xx=uy*zz-uz*zy,xy=uz*zx-ux*zz,xz=ux*zy-uy*zx;
  const xn=1/Math.hypot(xx,xy,xz); xx*=xn;xy*=xn;xz*=xn;
  let yx=zy*xz-zz*xy,yy=zz*xx-zx*xz,yz=zx*xy-zy*xx;
  const out=new Float32Array(16);
  out.set([xx,yx,zx,0,xy,yy,zy,0,xz,yz,zz,0,0,0,0,1]);
  out[12]=-(xx*ex+xy*ey+xz*ez);
  out[13]=-(yx*ex+yy*ey+yz*ez);
  out[14]=-(zx*ex+zy*ey+zz*ez);
  return out;
}
</script>
</body>
</html>
