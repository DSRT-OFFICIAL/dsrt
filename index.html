<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>WebGL2 — Cube + Keramik + Shadow Mapping</title>
<style>
  html,body{height:100%;margin:0;background:#111;overflow:hidden}
  canvas{display:block;width:100vw;height:100vh}
  #info{position:fixed;left:12px;top:12px;color:#fff;padding:8px 10px;border-radius:6px;background:rgba(0,0,0,0.35);font-family:system-ui,monospace;z-index:2}
</style>
</head>
<body>
<div id="info">WebGL2 ShadowMap — Drag: rotate • Wheel/pinch: zoom • Tap: color • Arrows: pan</div>
<canvas id="c"></canvas>

<!-- glMatrix -->
<script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/gl-matrix-min.js"></script>
<script>
(async()=>{

const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl2', {antialias:true});
if(!gl){ alert('WebGL2 tidak tersedia — gunakan Chrome/Firefox terbaru'); return; }

function resize(){
  const dpr = window.devicePixelRatio || 1;
  const w = Math.floor(canvas.clientWidth * dpr || innerWidth * dpr);
  const h = Math.floor(canvas.clientHeight * dpr || innerHeight * dpr);
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
    gl.viewport(0,0,w,h);
  }
}
window.addEventListener('resize', resize);
resize();

// -------------------- helpers --------------------
function compile(src, type){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s));
    throw new Error('Shader compile error');
  }
  return s;
}
function link(vs, fs){
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(p));
    throw new Error('Program link error');
  }
  return p;
}

// -------------------- SHADERS --------------------
// 1) Depth-only (render from light) -> output gl_Position
const vsDepthSrc = `#version 300 es
precision highp float;
layout(location=0) in vec3 aPos;
uniform mat4 uModel;
uniform mat4 uLightVP;
void main(){ gl_Position = uLightVP * uModel * vec4(aPos,1.0); }`;

const fsDepthSrc = `#version 300 es
precision highp float;
out vec4 outColor;
void main(){ /* depth written automatically */ outColor = vec4(0.0); }`;

// 2) Main pass (lighting + sample shadow map)
const vsMainSrc = `#version 300 es
precision highp float;
layout(location=0) in vec3 aPos;
layout(location=1) in vec3 aNormal;
layout(location=2) in vec2 aUV;

uniform mat4 uModel;
uniform mat4 uView;
uniform mat4 uProj;
uniform mat4 uLightVP;

out vec3 vWorldPos;
out vec3 vNormal;
out vec2 vUV;
out vec4 vLightSpacePos;

void main(){
  vec4 world = uModel * vec4(aPos,1.0);
  vWorldPos = world.xyz;
  vNormal = mat3(uModel) * aNormal;
  vUV = aUV;
  vLightSpacePos = uLightVP * world;
  gl_Position = uProj * uView * world;
}
`;

const fsMainSrc = `#version 300 es
precision highp float;

in vec3 vWorldPos;
in vec3 vNormal;
in vec2 vUV;
in vec4 vLightSpacePos;

uniform vec3 uLightPos;
uniform vec3 uViewPos;
uniform vec3 uBaseColor;
uniform vec3 uLightColor;
uniform float uShininess;
uniform sampler2D uShadowMap; // depth texture
uniform int uIsFloor;
uniform float uTileScale;

out vec4 outColor;

// simple function to get shadow factor using comparison
float getShadow(vec4 lightSpacePos){
  // perspective divide
  vec3 projCoords = lightSpacePos.xyz / lightSpacePos.w;
  // transform to [0,1]
  vec2 uv = projCoords.xy * 0.5 + 0.5;
  float currentDepth = projCoords.z * 0.5 + 0.5;
  // outside light frustum => no shadow (1.0)
  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) return 1.0;

  // sample depth from shadow map
  float bias = max(0.0005 * (1.0 - dot(normalize(vNormal), normalize(uLightPos - vWorldPos))), 0.0005);
  float shadowDepth = texture(uShadowMap, uv).r;
  // simple hard comparison
  float shadow = currentDepth - bias > shadowDepth ? 0.35 : 1.0;
  return shadow;
}

void main(){
  vec3 N = normalize(vNormal);
  vec3 L = normalize(uLightPos - vWorldPos);
  vec3 V = normalize(uViewPos - vWorldPos);
  vec3 R = reflect(-L, N);

  // ambient/diffuse/specular
  float diff = max(dot(N,L), 0.0);
  float spec = pow(max(dot(V, R), 0.0), uShininess);
  vec3 ambient = 0.15 * uBaseColor;
  vec3 diffuse = diff * uBaseColor * uLightColor;
  vec3 specular = spec * uLightColor * 0.5;

  vec3 color = ambient + diffuse + specular;

  // floor special: tiled white + grout
  if(uIsFloor == 1){
    vec2 st = vUV * uTileScale;
    vec2 f = fract(st);
    float lineWidth = 0.03;
    float gx = smoothstep(0.0, lineWidth, f.x) * (1.0 - smoothstep(1.0-lineWidth, 1.0, f.x));
    float gy = smoothstep(0.0, lineWidth, f.y) * (1.0 - smoothstep(1.0-lineWidth, 1.0, f.y));
    float groutMask = 1.0 - min(1.0, gx + gy);
    float noise = 0.98 + 0.04 * sin((st.x + st.y) * 12.9898);
    vec3 tileColor = vec3(1.0) * noise;
    vec3 groutColor = vec3(0.76);
    vec3 base = mix(groutColor, tileColor, groutMask);
    ambient = 0.15 * base;
    diffuse = diff * base * uLightColor;
    specular = spec * uLightColor * 0.6;
    color = ambient + diffuse + specular;
  }

  // shadow
  float shadow = getShadow(vLightSpacePos);
  color *= shadow;

  outColor = vec4(color, 1.0);
}
`;

// compile programs
const progDepth = link(compile(vsDepthSrc, gl.VERTEX_SHADER), compile(fsDepthSrc, gl.FRAGMENT_SHADER));
const progMain  = link(compile(vsMainSrc, gl.VERTEX_SHADER),  compile(fsMainSrc,  gl.FRAGMENT_SHADER));

// -------------------- geometry --------------------
// Cube data (positions, normals, uvs)
function createCube(size=1){
  const s = size/2;
  // 24 verts, each: pos(3) normal(3) uv(2)
  const P = [
    // front
    -s,-s, s,  0,0,1,  0,0,  s, -s, s,  0,0,1,  1,0,  s, s, s,  0,0,1, 1,1,  -s, s, s,  0,0,1, 0,1,
    // back
    s,-s,-s,  0,0,-1,  0,0,  -s,-s,-s, 0,0,-1, 1,0,  -s,s,-s, 0,0,-1, 1,1,  s,s,-s, 0,0,-1, 0,1,
    // top
    -s,s, s,  0,1,0,  0,0,  s,s, s, 0,1,0, 1,0,  s,s,-s,0,1,0, 1,1,  -s,s,-s,0,1,0, 0,1,
    // bottom
    -s,-s,-s, 0,-1,0, 0,0,  s,-s,-s,0,-1,0, 1,0,  s,-s,s,0,-1,0,1,1,  -s,-s,s,0,-1,0,0,1,
    // right
    s,-s,-s, 1,0,0, 0,0,  s,s,-s,1,0,0,1,0,  s,s, s,1,0,0,1,1,  s,-s, s,1,0,0,0,1,
    // left
    -s,-s,-s, -1,0,0,0,0,  -s,-s,s,-1,0,0,1,0,  -s,s,s,-1,0,0,1,1,  -s,s,-s,-1,0,0,0,1
  ];
  // flatten into Float32Array with stride 8 (3+3+2)
  return new Float32Array(P);
}
const cubeData = createCube(2.0);
const cubeIndices = new Uint16Array([
  0,1,2, 0,2,3,      // front
  4,5,6, 4,6,7,      // back
  8,9,10, 8,10,11,   // top
  12,13,14, 12,14,15,// bottom
  16,17,18, 16,18,19,// right
  20,21,22, 20,22,23 // left
]);

// Plane (single quad) with UVs large so shader tiles with uTileScale
const planeSize = 20;
const planeVerts = new Float32Array([
  -planeSize, 0, -planeSize,  0,1,0,  0,0,
   planeSize, 0, -planeSize,  0,1,0,  planeSize,0,
   planeSize, 0,  planeSize,  0,1,0,  planeSize,planeSize,
  -planeSize, 0,  planeSize,  0,1,0,  0,planeSize
]);
const planeIdx = new Uint16Array([0,1,2, 0,2,3]);

// -------------------- create VAOs --------------------
function createVAO(prog, verts, indices){
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

  // attributes: layout: pos(0) normal(1) uv(2)
  const stride = 8 * 4;
  gl.enableVertexAttribArray(0); gl.vertexAttribPointer(0,3,gl.FLOAT,false,stride,0);
  gl.enableVertexAttribArray(1); gl.vertexAttribPointer(1,3,gl.FLOAT,false,stride,3*4);
  gl.enableVertexAttribArray(2); gl.vertexAttribPointer(2,2,gl.FLOAT,false,stride,6*4);

  gl.bindVertexArray(null);
  return {vao, count: indices.length};
}
const cubeObj = createVAO(progMain, cubeData, cubeIndices);
const planeObj = createVAO(progMain, planeVerts, planeIdx);

// For depth program we only need positions; create simpler VAOs
function createSimpleVAO(verts, indices){
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  // supply only positions: stride 8*4, pos at offset 0
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,3,gl.FLOAT,false,8*4,0);
  gl.bindVertexArray(null);
  return {vao, count: indices.length};
}
const cubeDepthObj = createSimpleVAO(cubeData, cubeIndices);
const planeDepthObj = createSimpleVAO(planeVerts, planeIdx);

// -------------------- Shadow framebuffer / texture --------------------
const SHADOW_SIZE = 2048;
const depthTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, depthTexture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT24, SHADOW_SIZE, SHADOW_SIZE, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

const depthFBO = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, depthFBO);
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture, 0);
// no color buffer for depth-only
gl.drawBuffers([gl.NONE]);
gl.readBuffer(gl.NONE);
if(gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE){
  console.error('Shadow FBO incomplete');
}
gl.bindFramebuffer(gl.FRAMEBUFFER, null);

// -------------------- uniform locations --------------------
const locDepth = {
  uModel: gl.getUniformLocation(progDepth, 'uModel'),
  uLightVP: gl.getUniformLocation(progDepth, 'uLightVP')
};
const locMain = {
  uModel: gl.getUniformLocation(progMain, 'uModel'),
  uView: gl.getUniformLocation(progMain, 'uView'),
  uProj: gl.getUniformLocation(progMain, 'uProj'),
  uLightVP: gl.getUniformLocation(progMain, 'uLightVP'),
  uLightPos: gl.getUniformLocation(progMain, 'uLightPos'),
  uViewPos: gl.getUniformLocation(progMain, 'uViewPos'),
  uBaseColor: gl.getUniformLocation(progMain, 'uBaseColor'),
  uLightColor: gl.getUniformLocation(progMain, 'uLightColor'),
  uShininess: gl.getUniformLocation(progMain, 'uShininess'),
  uShadowMap: gl.getUniformLocation(progMain, 'uShadowMap'),
  uIsFloor: gl.getUniformLocation(progMain, 'uIsFloor'),
  uTileScale: gl.getUniformLocation(progMain, 'uTileScale')
};

// -------------------- controls/state --------------------
let camAngleX = 0, camAngleY = 0, camDist = 8;
let panX = 0, panY = 1.2, panZ = 0;
let dragging = false, lastX=0, lastY=0;
let lastTouchDist = null;
let tapStartTime = 0, tapStartX=0, tapStartY=0;
let cubeColor = [0.45,0.8,0.95];
const lightPos = [5.0, 8.0, 5.0];

canvas.addEventListener('mousedown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
window.addEventListener('mouseup', ()=>dragging=false);
window.addEventListener('mousemove', e=>{
  if(!dragging) return;
  const dx = e.clientX - lastX, dy = e.clientY - lastY;
  camAngleY += dx * 0.01;
  camAngleX += dy * 0.01;
  camAngleX = Math.max(-1.3, Math.min(1.3, camAngleX));
  lastX = e.clientX; lastY = e.clientY;
});
canvas.addEventListener('wheel', e=>{
  camDist += e.deltaY * 0.01;
  camDist = Math.max(2.0, Math.min(50.0, camDist));
  e.preventDefault();
}, {passive:false});

// touch gestures
canvas.addEventListener('touchstart', e=>{
  if(e.touches.length===1){
    tapStartTime = performance.now();
    tapStartX = e.touches[0].clientX; tapStartY = e.touches[0].clientY;
    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
  } else if(e.touches.length===2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    lastTouchDist = Math.hypot(dx,dy);
  }
});
canvas.addEventListener('touchmove', e=>{
  if(e.touches.length===1){
    camAngleY += (e.touches[0].clientX - lastX) * 0.01;
    camAngleX += (e.touches[0].clientY - lastY) * 0.01;
    camAngleX = Math.max(-1.3, Math.min(1.3, camAngleX));
    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
  } else if(e.touches.length===2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.hypot(dx,dy);
    if(lastTouchDist){
      camDist *= lastTouchDist / dist;
      camDist = Math.max(2.0, Math.min(50.0, camDist));
    }
    lastTouchDist = dist;
  }
}, {passive:false});
canvas.addEventListener('touchend', e=>{
  if(e.touches.length < 2) lastTouchDist = null;
  const dt = performance.now() - tapStartTime;
  if(dt < 220 && e.changedTouches && e.changedTouches.length>0){
    const dx = e.changedTouches[0].clientX - tapStartX;
    const dy = e.changedTouches[0].clientY - tapStartY;
    if(Math.hypot(dx,dy) < 12){
      // TAP: change cube color
      cubeColor = [Math.random(), Math.random(), Math.random()];
    }
  }
});

// keyboard pan
window.addEventListener('keydown', e=>{
  const step = 0.3;
  if(e.key === 'ArrowLeft') panX -= step;
  if(e.key === 'ArrowRight') panX += step;
  if(e.key === 'ArrowUp') panY += step;
  if(e.key === 'ArrowDown') panY -= step;
});

// -------------------- matrices --------------------
const mat4 = glMatrix.mat4;
const vec3 = glMatrix.vec3;

function computeLightVP(){
  // orthographic projection for directional-like light shadow (wider near)
  const lightView = mat4.create();
  mat4.lookAt(lightView, lightPos, [0,0,0], [0,1,0]);
  const s = 20.0;
  const lightProj = mat4.create();
  mat4.ortho(lightProj, -s, s, -s, s, 0.1, 60.0);
  const lightVP = mat4.create();
  mat4.multiply(lightVP, lightProj, lightView);
  return lightVP;
}

// -------------------- render loop --------------------
gl.enable(gl.DEPTH_TEST);
gl.enable(gl.CULL_FACE);

function render(t){
  resize();
  t *= 0.001;

  // 1) render depth from light into depthTexture
  gl.bindFramebuffer(gl.FRAMEBUFFER, depthFBO);
  gl.viewport(0,0,SHADOW_SIZE,SHADOW_SIZE);
  gl.clear(gl.DEPTH_BUFFER_BIT);
  gl.colorMask(false, false, false, false); // no color writes
  gl.useProgram(progDepth);

  const lightVP = computeLightVP();
  gl.uniformMatrix4fv(locDepth.uLightVP, false, lightVP);

  // cube depth
  let model = mat4.create();
  mat4.translate(model, model, [0, 1.2, 0]);
  mat4.rotateY(model, model, t * 0.9);
  gl.uniformMatrix4fv(locDepth.uModel, false, model);
  gl.bindVertexArray(cubeDepthObj.vao);
  gl.drawElements(gl.TRIANGLES, cubeDepthObj.count, gl.UNSIGNED_SHORT, 0);

  // floor depth
  mat4.identity(model);
  gl.uniformMatrix4fv(locDepth.uModel, false, model);
  gl.bindVertexArray(planeDepthObj.vao);
  gl.drawElements(gl.TRIANGLES, planeDepthObj.count, gl.UNSIGNED_SHORT, 0);

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.colorMask(true,true,true,true);

  // 2) main pass render from camera
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clearColor(0.09,0.09,0.10,1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  gl.useProgram(progMain);

  // camera view/proj
  const proj = mat4.create();
  mat4.perspective(proj, Math.PI/3, canvas.width/canvas.height, 0.1, 200);
  const view = mat4.create();
  // place camera with spherical controls around (panX, panY, panZ)
  const radius = camDist;
  const cx = panX + radius * Math.sin(camAngleY) * Math.cos(camAngleX);
  const cy = panY + radius * Math.sin(camAngleX);
  const cz = panZ + radius * Math.cos(camAngleY) * Math.cos(camAngleX);
  mat4.lookAt(view, [cx,cy,cz], [panX, 0.8, panZ], [0,1,0]);

  // common uniforms
  gl.uniformMatrix4fv(locMain.uProj, false, proj);
  gl.uniformMatrix4fv(locMain.uView, false, view);
  gl.uniformMatrix4fv(locMain.uLightVP, false, lightVP);
  gl.uniform3fv(locMain.uLightPos, lightPos);
  gl.uniform3fv(locMain.uLightColor, [1,1,1]);
  gl.uniform1f(locMain.uShininess, 32.0);
  gl.uniform3fv(locMain.uViewPos, [cx,cy,cz]);

  // bind shadow map to texture unit 0
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, depthTexture);
  gl.uniform1i(locMain.uShadowMap, 0);

  // -- draw floor --
  mat4.identity(model);
  gl.uniformMatrix4fv(locMain.uModel, false, model);
  gl.uniform1i(locMain.uIsFloor, 1);
  gl.uniform1f(locMain.uTileScale, 40.0);
  gl.bindVertexArray(planeObj.vao);
  gl.drawElements(gl.TRIANGLES, planeObj.count, gl.UNSIGNED_SHORT, 0);

  // -- draw cube (rotating) --
  mat4.identity(model);
  mat4.translate(model, model, [0, 1.2, 0]);
  mat4.rotateY(model, model, t * 0.9);
  mat4.rotateX(model, model, t * 0.6);
  gl.uniformMatrix4fv(locMain.uModel, false, model);
  gl.uniform1i(locMain.uIsFloor, 0);
  gl.uniform3fv(locMain.uBaseColor, cubeColor);
  gl.bindVertexArray(cubeObj.vao);
  gl.drawElements(gl.TRIANGLES, cubeObj.count, gl.UNSIGNED_SHORT, 0);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);

})(); // end async
</script>
</body>
</html>
