<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DSRT Engine AI-Ready</title>
<style>
  body { margin:0; overflow:hidden; font-family:sans-serif; }
  #menu { position:absolute; top:10px; left:10px; z-index:10; }
  #menu button { margin:2px; padding:5px 10px; }
  #gui { position:absolute; top:10px; right:10px; z-index:10; width:350px; max-height:95vh; overflow:auto; }
  #infoPanel { position:absolute; bottom:10px; left:10px; color:white; font-family:sans-serif; background:rgba(0,0,0,0.5); padding:5px; }
</style>
</head>
<body>

<div id="menu">
  <button id="startBtn">Start</button>
  <button id="resetBtn">Reset</button>
  <button id="spawnCubeBtn">Spawn Cube</button>
  <button id="spawnRobotBtn">Spawn Robot</button>
  <button id="spawnSphereBtn">Spawn Sphere</button>
  <button id="removeLastBtn">Remove Last</button>
</div>
<div id="gui"></div>
<div id="infoPanel">Hover over object to see info</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lil-gui@0.18.0/dist/lil-gui.min.js"></script>

<!-- Mentahan Formulation Engine + Tensor/Matrices -->
<script>
const FormulationEngine = {
  add:(a,b)=>a+b,
  multiply:(a,b)=>a*b,
  clamp:(v,min,max)=>Math.min(Math.max(v,min),max),
  tensorAdd:(a,b)=>a.map((v,i)=>v+(b[i]||0)),
  tensorMultiply:(a,b)=>a.map((v,i)=>v*(b[i]||1)),
  vectorDistance:(a,b)=>Math.sqrt((a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2)
};
</script>

<script>
/* ===== Scene / Camera / Renderer ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
camera.position.set(10,8,15);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.shadowMap.enabled=true;
renderer.shadowMap.type=THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera,renderer.domElement);
controls.enableDamping=true;

/* ===== Lights ===== */
scene.add(new THREE.AmbientLight(0x404040));
const dirLight=new THREE.DirectionalLight(0xffffff,1);
dirLight.position.set(10,15,10);
dirLight.castShadow=true;
scene.add(dirLight);

/* ===== Helpers ===== */
scene.add(new THREE.GridHelper(30,30));
scene.add(new THREE.AxesHelper(5));

/* ===== Floor ===== */
const floorGeo=new THREE.PlaneGeometry(30,30);
const floorMat=new THREE.MeshStandardMaterial({color:0x303030,side:THREE.DoubleSide});
const floor=new THREE.Mesh(floorGeo,floorMat);
floor.rotation.x=-Math.PI/2;
floor.receiveShadow=true;
scene.add(floor);

/* ===== Objects / GUI / Info ===== */
const objects = [];
const infoPanel = document.getElementById('infoPanel');
const gui = new lil.GUI({container:document.getElementById('gui')});

/* ===== Object Creation Functions ===== */
function addGUI(obj,name){
  const folder = gui.addFolder(name);
  if(obj.position){ folder.add(obj.position,'x',-15,15); folder.add(obj.position,'y',0,10); folder.add(obj.position,'z',-15,15); }
  if(obj.rotation){ folder.add(obj.rotation,'x',0,Math.PI*2); folder.add(obj.rotation,'y',0,Math.PI*2); folder.add(obj.rotation,'z',0,Math.PI*2); }
  if(obj.scale){ folder.add(obj.scale,'x',0.1,5); folder.add(obj.scale,'y',0.1,5); folder.add(obj.scale,'z',0.1,5); }
  if(obj.material && obj.material.color) folder.addColor(obj.material,'color');
  if(obj.userData.velocity!==undefined) folder.add(obj.userData,'velocity',0,0.1);
  if(obj.userData.path!==undefined) folder.add(obj.userData,'pathIndex',0,obj.userData.path.length-1).listen();
  folder.open();
}

function createCube(color=0x00ff00,pos={x:0,y:0.5,z:0}){
  const geo = new THREE.BoxGeometry(1,1,1);
  const mat = new THREE.MeshStandardMaterial({color});
  const cube = new THREE.Mesh(geo,mat);
  cube.position.set(pos.x,pos.y,pos.z);
  cube.castShadow=true;
  scene.add(cube);
  objects.push(cube);
  addGUI(cube,'Cube '+objects.length);
  return cube;
}

function createRobot(colorHead=0xff0000,colorBody=0x0000ff,posX=0){
  const robot = new THREE.Group();
  const head = new THREE.Mesh(new THREE.BoxGeometry(1,0.5,1),new THREE.MeshStandardMaterial({color:colorHead}));
  head.position.y=1.5;
  const body = new THREE.Mesh(new THREE.BoxGeometry(1,1,1),new THREE.MeshStandardMaterial({color:colorBody}));
  body.position.y=0.5;
  robot.add(head,body);
  robot.position.x=posX;
  robot.userData.velocity = (posX<0?0.02:-0.015);
  // AI-style dynamic path (tensor/matrix mentah)
  robot.userData.path=[
    [posX,0.5,0],
    [posX*0.5,0.5,5],
    [-posX,0.5,0],
    [-posX*0.5,0.5,-5]
  ];
  robot.userData.pathIndex = 0;
  scene.add(robot);
  objects.push(robot);
  addGUI(robot,'Robot '+objects.length);
  return robot;
}

function createSphere(color=0xff00ff,pos={x:0,y:0.5,z:0}){
  const geo = new THREE.SphereGeometry(0.5,32,32);
  const mat = new THREE.MeshStandardMaterial({color});
  const sphere = new THREE.Mesh(geo,mat);
  sphere.position.set(pos.x,pos.y,pos.z);
  sphere.castShadow=true;
  sphere.userData.dir=0.01;
  scene.add(sphere);
  objects.push(sphere);
  addGUI(sphere,'Sphere '+objects.length);
  return sphere;
}

/* ===== Initial Objects ===== */
const cube = createCube();
const robot1 = createRobot(undefined,undefined,-5);
const robot2 = createRobot(0xffaa00,0x00aaff,5);
const sphere = createSphere();

/* ===== Raycaster / Interaction ===== */
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
window.addEventListener('mousemove',e=>{
  mouse.x = (e.clientX/window.innerWidth)*2-1;
  mouse.y = -(e.clientY/window.innerHeight)*2+1;
});

/* ===== Menu Buttons ===== */
document.getElementById('startBtn').onclick=()=>{ objects.forEach(obj=>{ if(obj.userData.velocity!==undefined) obj.userData.velocity=Math.abs(obj.userData.velocity); }); };
document.getElementById('resetBtn').onclick=()=>{ location.reload(); };
document.getElementById('spawnCubeBtn').onclick=()=>{ createCube(Math.random()*0xffffff,{x:(Math.random()-0.5)*20,y:0.5,z:(Math.random()-0.5)*20}); };
document.getElementById('spawnRobotBtn').onclick=()=>{ createRobot(Math.random()*0xffffff,Math.random()*0xffffff,(Math.random()-0.5)*20); };
document.getElementById('spawnSphereBtn').onclick=()=>{ createSphere(Math.random()*0xffffff,{x:(Math.random()-0.5)*20,y:0.5,z:(Math.random()-0.5)*20}); };
document.getElementById('removeLastBtn').onclick=()=>{ const obj=objects.pop(); if(obj){ scene.remove(obj); gui.destroy(); } };

/* ===== Resize ===== */
window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

/* ===== Update Objects / AI Paths ===== */
function updateObjects(){
  objects.forEach(obj=>{
    // Robot AI path
    if(obj.userData.path){
      const path = obj.userData.path;
      const target = path[obj.userData.pathIndex];
      obj.position.x += (target[0]-obj.position.x)*0.02;
      obj.position.y += (target[1]-obj.position.y)*0.02;
      obj.position.z += (target[2]-obj.position.z)*0.02;
      if(FormulationEngine.vectorDistance([obj.position.x,obj.position.y,obj.position.z],target)<0.1){
        obj.userData.pathIndex = (obj.userData.pathIndex+1)%path.length;
      }
    }
    // Cube / Robot simple velocity
    if(obj.userData.velocity!==undefined && !obj.userData.path){
      obj.position.x += obj.userData.velocity;
      if(obj.position.x>15 || obj.position.x<-15) obj.userData.velocity*=-1;
    }
    // Sphere vertical oscillation
    if(obj.userData.dir!==undefined){
      obj.position.y += obj.userData.dir;
      if(obj.position.y>3 || obj.position.y<0.5) obj.userData.dir*=-1;
    }
  });
}

/* ===== Check Intersections / Hover Info ===== */
function checkIntersections(){
  raycaster.setFromCamera(mouse,camera);
  const intersects = raycaster.intersectObjects(objects,true);
  if(intersects.length>0){
    const obj = intersects[0].object;
    infoPanel.innerText = `Hovering: ${obj.name||obj.type} Pos: ${obj.position.x.toFixed(2)},${obj.position.y.toFixed(2)},${obj.position.z.toFixed(2)}`;
    obj.material.color.set(0xffff00);
  } else infoPanel.innerText = 'Hover over object to see info';
}

/* ===== Animate ===== */
function animate(){
  requestAnimationFrame(animate);
  cube.rotation.x = FormulationEngine.add(cube.rotation.x,0.01);
  cube.rotation.y = FormulationEngine.add(cube.rotation.y,0.01);
  updateObjects();
  checkIntersections();
  controls.update();
  renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>
