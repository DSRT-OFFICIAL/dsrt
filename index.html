<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Modern Cube â€” Reflection + Soft Shadow (WebGL2)</title>
<style>
  :root{--ui-bg:rgba(255,255,255,0.88);--accent:#0ea5a4}
  html,body{height:100%;margin:0;background:#ffffff;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}
  .ui{position:fixed;left:12px;top:12px;background:var(--ui-bg);padding:10px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.08);font-size:13px}
  .row{display:flex;gap:8px;align-items:center;margin-bottom:6px}
  .small{font-size:12px;color:#334155}
  input[type=range]{width:140px}
  button{padding:6px 10px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer}
</style>
</head>
<body>
<canvas id="gl"></canvas>
<div class="ui">
  <div style="font-weight:600">Modern Cube</div>
  <div class="row"><label class="small">Shininess <input id="shin" type="range" min="2" max="256" value="48"></label><span id="sval" class="small">48</span></div>
  <div class="row"><label class="small">Light Intensity <input id="lint" type="range" min="0" max="4" step="0.1" value="1.2"></label><span id="lintv" class="small">1.2</span></div>
  <div class="row"><label class="small"><input id="refl" type="checkbox" checked> Reflection</label><label class="small" style="margin-left:8px"><input id="shad" type="checkbox" checked> Soft Shadow</label></div>
  <div class="row"><button id="reset">Reset View</button></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.5.0/gl-matrix-min.js"></script>
<script type="module">
const { mat4, mat3, vec3 } = glMatrix;
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl2', { antialias: true });
if(!gl){ document.body.innerHTML = '<div style="padding:20px;color:#000">WebGL2 tidak didukung</div>'; throw new Error('No WebGL2'); }

function resize(){ const dpr = Math.max(1, devicePixelRatio||1); canvas.width = Math.floor(innerWidth*dpr); canvas.height = Math.floor(innerHeight*dpr); gl.viewport(0,0,canvas.width,canvas.height); }
addEventListener('resize', resize); resize();

// ---------------- SHADERS ----------------
const vs = `#version 300 es
layout(location=0) in vec3 aPos;
layout(location=1) in vec3 aNormal;
layout(location=2) in vec2 aUv;

uniform mat4 uModel;
uniform mat4 uView;
uniform mat4 uProj;
uniform mat3 uNormalMat;

out vec3 vWorld;
out vec3 vNormal;
out vec2 vUv;

void main(){
  vec4 world = uModel * vec4(aPos,1.0);
  vWorld = world.xyz;
  vNormal = normalize(uNormalMat * aNormal);
  vUv = aUv;
  gl_Position = uProj * uView * world;
}
`;

const fs = `#version 300 es
precision highp float;
in vec3 vWorld;
in vec3 vNormal;
in vec2 vUv;
out vec4 outColor;

uniform vec3 uLightPos;
uniform vec3 uCamPos;
uniform float uLightIntensity;
uniform float uShininess;
uniform samplerCube uEnv;
uniform float uUseRefl;
uniform float uUseShadow;
uniform vec3 uBaseColor;

// simple soft shadow projected on plane y=0 using distance of world.xz to shadow center (cube center)
float softShadow(vec3 world){
  if(uUseShadow < 0.5) return 1.0;
  // project position onto ground plane (y= -1) assuming model center moves above ground ~0
  float sx = world.x;
  float sz = world.z;
  float r = length(vec2(sx, sz));
  float sigma = 0.9;
  float s = exp(- (r*r) / (2.0 * sigma*sigma));
  // also dim based on light elevation
  float lightElev = clamp(uLightPos.y / 6.0, 0.1, 2.0);
  return mix(1.0 - 0.6*s, 1.0, 0.0); // return multiplier (we'll multiply diffuse by this factor: darker near center)
}

vec3 ACESFilm(vec3 x){
  x = max(vec3(0.0), x - 0.004);
  return (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);
}

void main(){
  vec3 N = normalize(vNormal);
  vec3 L = normalize(uLightPos - vWorld);
  vec3 V = normalize(uCamPos - vWorld);
  vec3 H = normalize(L + V);

  vec3 albedo = uBaseColor;

  // diffuse
  float dif = max(dot(N,L), 0.0);
  // specular
  float spec = pow(max(dot(N,H), 0.0), uShininess);

  // reflection (sample environment)
  vec3 reflColor = vec3(0.0);
  if(uUseRefl > 0.5){
    vec3 I = normalize(vWorld - uCamPos);
    vec3 R = reflect(I, N);
    reflColor = texture(uEnv, R).rgb;
  }

  // final composition
  float shadowMul = softShadow(vWorld);
  vec3 color = 0.08 * albedo + uLightIntensity * (dif * albedo * shadowMul + spec * vec3(1.0) * 0.4);
  // blend reflection (Fresnel-ish)
  float fresnel = pow(1.0 - max(dot(N,V), 0.0), 3.0);
  color = mix(color, reflColor, fresnel * 0.9);

  color = ACESFilm(color);
  color = pow(color, vec3(1.0/2.2));
  outColor = vec4(color, 1.0);
}
`;

// compile/link
function compile(src, type){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s); if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s)); return s; }
function link(vsSrc, fsSrc){ const p=gl.createProgram(); gl.attachShader(p, compile(vsSrc,gl.VERTEX_SHADER)); gl.attachShader(p, compile(fsSrc,gl.FRAGMENT_SHADER)); gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(p)); return p;}
const prog = link(vs, fs);

// ---------------- GEOMETRY ----------------
function makeCube(){ // 24 verts
  const P = [
    // front +Z
    -1,-1, 1,  1,-1,1,  1,1,1, -1,1,1,
    // back -Z
    1,-1,-1, -1,-1,-1, -1,1,-1, 1,1,-1,
    // top +Y
    -1,1,1, 1,1,1, 1,1,-1, -1,1,-1,
    // bottom -Y
    -1,-1,-1, 1,-1,-1, 1,-1,1, -1,-1,1,
    // right +X
    1,-1,1, 1,-1,-1, 1,1,-1, 1,1,1,
    // left -X
    -1,-1,-1, -1,-1,1, -1,1,1, -1,1,-1
  ];
  const N = [
    0,0,1,0,0,1,0,0,1,0,0,1,
    0,0,-1,0,0,-1,0,0,-1,0,0,-1,
    0,1,0,0,1,0,0,1,0,0,1,0,
    0,-1,0,0,-1,0,0,-1,0,0,-1,0,
    1,0,0,1,0,0,1,0,0,1,0,0,
    -1,0,0,-1,0,0,-1,0,0,-1,0,0
  ];
  const UV = new Array(24).fill(0).flatMap((_,i)=> {
    const q = Math.floor(i/4);
    const uvs = [[0,0],[1,0],[1,1],[0,1]][i%4];
    return uvs;
  });
  const I = [
    0,1,2, 0,2,3,
    4,5,6, 4,6,7,
    8,9,10, 8,10,11,
    12,13,14, 12,14,15,
    16,17,18, 16,18,19,
    20,21,22, 20,22,23
  ];
  return {positions: new Float32Array(P), normals: new Float32Array(N), uvs: new Float32Array(UV), indices: new Uint16Array(I)};
}
function makePlane(size=10){
  const s=size;
  const P = [-s,0,-s,  s,0,-s,  s,0,s,  -s,0,s];
  const N = [0,1,0, 0,1,0, 0,1,0, 0,1,0];
  const UV = [0,0, 1,0, 1,1, 0,1];
  const I = [0,1,2, 0,2,3];
  return {positions:new Float32Array(P), normals:new Float32Array(N), uvs:new Float32Array(UV), indices:new Uint16Array(I)};
}

const cubeGeo = makeCube();
const planeGeo = makePlane(8);

// create VAO
const vao = gl.createVertexArray(); gl.bindVertexArray(vao);
function createArrayBuffer(data, loc, size){
  const b = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, b); gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(loc); gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
}
createArrayBuffer(cubeGeo.positions, 0, 3);
createArrayBuffer(cubeGeo.normals, 1, 3);
createArrayBuffer(cubeGeo.uvs, 2, 2);
const ib = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeGeo.indices, gl.STATIC_DRAW);
gl.bindVertexArray(null);

// plane VAO
const vaoPlane = gl.createVertexArray(); gl.bindVertexArray(vaoPlane);
createArrayBuffer(planeGeo.positions, 0, 3);
createArrayBuffer(planeGeo.normals, 1, 3);
createArrayBuffer(planeGeo.uvs, 2, 2);
const ibp = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibp); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, planeGeo.indices, gl.STATIC_DRAW);
gl.bindVertexArray(null);

// ----------------- CUBEMAP (procedural) -----------------
function makeCubeFaceColor(r,g,b){
  const c = document.createElement('canvas'); c.width=c.height=128;
  const ctx = c.getContext('2d');
  ctx.fillStyle = `rgb(${r},${g},${b})`; ctx.fillRect(0,0,128,128);
  // soft gradient
  const ggrad = ctx.createRadialGradient(64,64,10,64,64,80); ggrad.addColorStop(0,'rgba(255,255,255,0.12)'); ggrad.addColorStop(1,'rgba(0,0,0,0.06)');
  ctx.fillStyle = ggrad; ctx.fillRect(0,0,128,128);
  return c;
}
const cubeTex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubeTex);
const faces = [
  {t:gl.TEXTURE_CUBE_MAP_POSITIVE_X, img: makeCubeFaceColor(200,220,255)},
  {t:gl.TEXTURE_CUBE_MAP_NEGATIVE_X, img: makeCubeFaceColor(200,200,255)},
  {t:gl.TEXTURE_CUBE_MAP_POSITIVE_Y, img: makeCubeFaceColor(240,240,255)},
  {t:gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, img: makeCubeFaceColor(180,200,230)},
  {t:gl.TEXTURE_CUBE_MAP_POSITIVE_Z, img: makeCubeFaceColor(210,230,255)},
  {t:gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, img: makeCubeFaceColor(200,210,240)},
];
faces.forEach(f => { gl.texImage2D(f.t, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, f.img); });
gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);

// ---------------- UNIFORMS LOC ----------------
gl.useProgram(prog);
const UL = {
  uModel: gl.getUniformLocation(prog,'uModel'),
  uView: gl.getUniformLocation(prog,'uView'),
  uProj: gl.getUniformLocation(prog,'uProj'),
  uNormalMat: gl.getUniformLocation(prog,'uNormalMat'),
  uLightPos: gl.getUniformLocation(prog,'uLightPos'),
  uCamPos: gl.getUniformLocation(prog,'uCamPos'),
  uLightIntensity: gl.getUniformLocation(prog,'uLightIntensity'),
  uShininess: gl.getUniformLocation(prog,'uShininess'),
  uEnv: gl.getUniformLocation(prog,'uEnv'),
  uUseRefl: gl.getUniformLocation(prog,'uUseRefl'),
  uUseShadow: gl.getUniformLocation(prog,'uUseShadow'),
  uBaseColor: gl.getUniformLocation(prog,'uBaseColor')
};
gl.uniform1i(UL.uEnv, 0);

// ---------------- STATE & CONTROLS ----------------
let radius = 5.0, theta = Math.PI*0.25, phi = Math.PI*0.35, dragging=false, lx=0, ly=0;
canvas.addEventListener('pointerdown',(e)=>{ dragging=true; lx=e.clientX; ly=e.clientY; canvas.setPointerCapture(e.pointerId);});
canvas.addEventListener('pointerup',(e)=>{ dragging=false; canvas.releasePointerCapture(e.pointerId);});
canvas.addEventListener('pointermove',(e)=>{ if(!dragging) return; const dx=e.clientX-lx, dy=e.clientY-ly; lx=e.clientX; ly=e.clientY; theta-=dx*0.006; phi=Math.min(Math.max(0.05,phi-dy*0.006),Math.PI-0.05); });
canvas.addEventListener('wheel',(e)=>{ e.preventDefault(); radius = Math.max(2, Math.min(12, radius + e.deltaY*0.01)); }, {passive:false});

// UI
const shin = document.getElementById('shin'), sval = document.getElementById('sval');
const lint = document.getElementById('lint'), lintv = document.getElementById('lintv');
const refl = document.getElementById('refl'), shad = document.getElementById('shad'), reset = document.getElementById('reset');
shin.addEventListener('input', ()=> sval.textContent=shin.value);
lint.addEventListener('input', ()=> lintv.textContent=lint.value);
reset.addEventListener('click', ()=>{ radius=5; theta=Math.PI*0.25; phi=Math.PI*0.35; });

// ---------------- RENDER ----------------
gl.enable(gl.DEPTH_TEST); gl.enable(gl.CULL_FACE);

function getCameraMatrix(){
  const eye = [ radius*Math.sin(phi)*Math.cos(theta), radius*Math.cos(phi), radius*Math.sin(phi)*Math.sin(theta) ];
  const view = mat4.create(); mat4.lookAt(view, eye, [0,0,0], [0,1,0]);
  return {view, eye};
}

const proj = mat4.create();
function updateProj(){ mat4.perspective(proj, Math.PI/4, canvas.width/canvas.height, 0.1, 100.0); }
updateProj();

let t0 = 0;
function frame(t){
  resize(); updateProj();
  t *= 0.001; const dt = t - t0; t0 = t;

  const cam = getCameraMatrix();
  const view = cam.view;
  const eye = cam.eye;

  // model: floating + rotation
  const model = mat4.create();
  mat4.translate(model, model, [0, Math.sin(t*1.6)*0.25 + 0.6, 0]); // melayang a bit
  mat4.rotateY(model, model, t*0.9);
  mat4.rotateX(model, model, t*0.4);
  const normalMat = mat3.create(); mat3.normalFromMat4(normalMat, model);

  gl.useProgram(prog);
  gl.uniformMatrix4fv(UL.uModel, false, model);
  gl.uniformMatrix4fv(UL.uView, false, view);
  gl.uniformMatrix4fv(UL.uProj, false, proj);
  gl.uniformMatrix3fv(UL.uNormalMat, false, normalMat);

  const lightPos = [ 4.0*Math.cos(t*0.6), 3.5 + Math.sin(t*0.9)*0.6, 4.0*Math.sin(t*0.6) ];
  gl.uniform3fv(UL.uLightPos, lightPos);
  gl.uniform3fv(UL.uCamPos, eye);
  gl.uniform1f(UL.uLightIntensity, parseFloat(lint.value));
  gl.uniform1f(UL.uShininess, parseFloat(shin.value));
  gl.uniform1f(UL.uUseRefl, refl.checked ? 1.0 : 0.0);
  gl.uniform1f(UL.uUseShadow, shad.checked ? 1.0 : 0.0);
  gl.uniform3fv(UL.uBaseColor, [0.98,0.92,0.86]);

  // clear white background
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clearColor(1,1,1,1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // bind cubemap to unit 0
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, cubeTex);

  // draw plane (ground) as subtle gray with center darker (so shadow visible)
  // draw plane using same shader but base color near white and no reflection effect
  const planeModel = mat4.create();
  mat4.translate(planeModel, planeModel, [0, -0.99, 0]); // ground at y=-0.99
  mat4.scale(planeModel, planeModel, [1,1,1]);
  const nmPlane = mat3.create(); mat3.normalFromMat4(nmPlane, planeModel);
  gl.uniformMatrix4fv(UL.uModel, false, planeModel);
  gl.uniformMatrix3fv(UL.uNormalMat, false, nmPlane);
  gl.uniform3fv(UL.uBaseColor, [0.96,0.96,0.96]);
  gl.uniform1f(UL.uUseRefl, 0.0); // no reflection on floor
  gl.bindVertexArray(vaoPlane);
  gl.drawElements(gl.TRIANGLES, planeGeo.indices.length, gl.UNSIGNED_SHORT, 0);
  gl.bindVertexArray(null);

  // draw cube
  gl.uniformMatrix4fv(UL.uModel, false, model);
  gl.uniformMatrix3fv(UL.uNormalMat, false, normalMat);
  gl.bindVertexArray(vao);
  gl.drawElements(gl.TRIANGLES, cubeGeo.indices.length, gl.UNSIGNED_SHORT, 0);
  gl.bindVertexArray(null);

  // Draw soft blob shadow (screen-space overlay) by rendering a transparent quad on top using 2D canvas
  // but to keep everything in single WebGL shader, we'll render a simple blended circle onto the ground:
  // We'll emulate by drawing a dark, semi-transparent circle in clip-space via gl.scissor + blending onto ground location.
  if(shad.checked){
    // compute shadow center in clip space by projecting cube world origin (0, cubeY, 0) to NDC
    const worldCenter = vec3.fromValues(0, Math.sin(t*1.6)*0.25 + 0.6, 0);
    const mvp = mat4.create(); mat4.multiply(mvp, proj, view); mat4.multiply(mvp, mvp, mat4.create()); // projection*view*I
    const wc = vec4FromVec3(worldCenter,1);
    const clip = multiplyMat4Vec4(mvp, wc);
    const ndc = [clip[0]/clip[3], clip[1]/clip[3]];
    // compute screen pixel center
    const sx = (ndc[0]*0.5+0.5)*canvas.width, sy = (1.0 - (ndc[1]*0.5+0.5))*canvas.height;
    // draw with 2D overlay
    drawShadowOverlay(sx, sy, 180 * (1.0 + Math.sin(t*2.0)*0.05), 0.5 * (parseFloat(lint.value)));
  }

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

// ---------- Simple 2D overlay for soft shadow ----------
const overlay = document.createElement('canvas'); overlay.style.position='fixed'; overlay.style.left='0'; overlay.style.top='0';
overlay.width = canvas.width; overlay.height = canvas.height; overlay.style.pointerEvents='none';
document.body.appendChild(overlay);
const octx = overlay.getContext('2d');
function resizeOverlay(){ overlay.width = canvas.width; overlay.height = canvas.height; octx.clearRect(0,0,overlay.width,overlay.height); }
addEventListener('resize', resizeOverlay);
function drawShadowOverlay(x,y,rad,alpha){
  octx.clearRect(0,0,overlay.width,overlay.height);
  const g = octx.createRadialGradient(x,y,rad*0.05,x,y,rad);
  g.addColorStop(0, `rgba(0,0,0,${0.28*alpha})`);
  g.addColorStop(1, 'rgba(0,0,0,0)');
  octx.fillStyle = g;
  octx.beginPath(); octx.fillRect(0,0,overlay.width,overlay.height); octx.fill();
}

// helpers
function vec4FromVec3(v,w){ return [v[0],v[1],v[2],w]; }
function multiplyMat4Vec4(m,v){ const r=[0,0,0,0]; for(let i=0;i<4;i++){ r[i]=m[i]*v[0]+m[i+4]*v[1]+m[i+8]*v[2]+m[i+12]*v[3]; } return r; }

// initial UI sync
sval.textContent = shin.value; lintv.textContent = lint.value;

</script>
</body>
</html>
