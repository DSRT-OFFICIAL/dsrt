<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Arena — Keramik + Cube + Shadow (WebGL2, no libs)</title>
<style>
  html,body{height:100%;margin:0;background:#87c0ff;}
  canvas{display:block;width:100vw;height:100vh;}
  #hint{position:fixed;left:12px;top:12px;background:rgba(0,0,0,0.32);color:#fff;padding:8px 10px;border-radius:6px;font-family:system-ui,monospace;z-index:2}
</style>
</head>
<body>
<div id="hint">Drag: rotate • Wheel/pinch: zoom • Tap: color • Arrow keys: pan</div>
<canvas id="gl"></canvas>

<script>
/*
  Full WebGL2 scene:
  - Shadow mapping (depth-only pass from light -> sample in main pass)
  - Floor tiled (white ceramic) with thicker/darker grout
  - Rotating floating cube that casts shadow
  - Transparent walls around arena receiving shadows
  - Camera auto-rotate with manual override (mouse/touch)
  - Tap to change cube color, pinch to zoom
  - No external libraries / no brand names
*/

// ---------- init ----------
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl2', {antialias:true});
if(!gl){ alert('WebGL2 required. Gunakan browser modern.'); throw new Error('WebGL2 unavailable'); }

function resize(){
  const dpr = window.devicePixelRatio || 1;
  const w = Math.floor(canvas.clientWidth * dpr || innerWidth * dpr);
  const h = Math.floor(canvas.clientHeight * dpr || innerHeight * dpr);
  if(canvas.width !== w || canvas.height !== h){
    canvas.width = w; canvas.height = h;
    gl.viewport(0,0,w,h);
  }
}
window.addEventListener('resize', resize);
resize();

// ---------- shader helpers ----------
function compile(src, type){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    console.error(gl.getShaderInfoLog(s));
    throw new Error('Shader compile error');
  }
  return s;
}
function link(vs, fs){
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(p));
    throw new Error('Program link error');
  }
  return p;
}

// ---------- depth (shadow) program ----------
const vsDepth = `#version 300 es
precision highp float;
layout(location=0) in vec3 aPos;
uniform mat4 uModel;
uniform mat4 uLightVP;
void main(){
  gl_Position = uLightVP * uModel * vec4(aPos, 1.0);
}
`;
const fsDepth = `#version 300 es
precision highp float;
out vec4 oColor;
void main(){ oColor = vec4(0.0); } // depth written to depth attachment
`;
const progDepth = link(compile(vsDepth, gl.VERTEX_SHADER), compile(fsDepth, gl.FRAGMENT_SHADER));

// ---------- main program (lighting + shadow sampling + tiled floor) ----------
const vsMain = `#version 300 es
precision highp float;
layout(location=0) in vec3 aPos;
layout(location=1) in vec3 aNormal;
layout(location=2) in vec2 aUV;

uniform mat4 uModel;
uniform mat4 uView;
uniform mat4 uProj;
uniform mat4 uLightVP;

out vec3 vWorldPos;
out vec3 vNormal;
out vec2 vUV;
out vec4 vLightSpace;

void main(){
  vec4 world = uModel * vec4(aPos, 1.0);
  vWorldPos = world.xyz;
  vNormal = mat3(uModel) * aNormal;
  vUV = aUV;
  vLightSpace = uLightVP * world;
  gl_Position = uProj * uView * world;
}
`;

const fsMain = `#version 300 es
precision highp float;
in vec3 vWorldPos;
in vec3 vNormal;
in vec2 vUV;
in vec4 vLightSpace;

uniform vec3 uLightPos;
uniform vec3 uLightColor;
uniform vec3 uViewPos;
uniform vec3 uBaseColor;
uniform int uIsFloor;
uniform float uTileScale;
uniform float uLineWidth; // grout thickness (0..0.2)
uniform sampler2D uShadowMap;

out vec4 fragColor;

// simple PCF sampling for soft shadow (3x3)
float sampleShadow(vec2 uv, float compareDepth, float texelSize){
  float sum = 0.0;
  float samples = 0.0;
  for(int x=-1; x<=1; x++){
    for(int y=-1; y<=1; y++){
      vec2 off = vec2(float(x), float(y)) * texelSize;
      float d = texture(uShadowMap, uv + off).r;
      sum += (compareDepth - 0.0007) > d ? 0.0 : 1.0;
      samples += 1.0;
    }
  }
  return sum / samples;
}

void main(){
  vec3 N = normalize(vNormal);
  vec3 L = normalize(uLightPos - vWorldPos);
  vec3 V = normalize(uViewPos - vWorldPos);
  vec3 R = reflect(-L, N);

  // basic Phong components
  float diff = max(dot(N, L), 0.0);
  float spec = pow(max(dot(V, R), 0.0), 32.0);

  vec3 ambient = 0.15 * uBaseColor;
  vec3 diffuse = diff * uBaseColor * uLightColor;
  vec3 specular = 0.5 * spec * uLightColor;
  vec3 color = ambient + diffuse + specular;

  // floor special: tiled white + grout
  if(uIsFloor == 1){
    vec2 st = vUV * uTileScale;
    vec2 f = fract(st);
    float lw = clamp(uLineWidth, 0.001, 0.2);
    // compute mask for lines (grout)
    float gx = smoothstep(0.0, lw, f.x) * (1.0 - smoothstep(1.0-lw, 1.0, f.x));
    float gy = smoothstep(0.0, lw, f.y) * (1.0 - smoothstep(1.0-lw, 1.0, f.y));
    float grout = 1.0 - min(1.0, gx + gy);
    // tile noise
    float noise = 0.98 + 0.04 * sin((st.x + st.y) * 12.9898);
    vec3 tileColor = vec3(1.0) * noise;
    vec3 groutColor = vec3(0.65); // darker grout
    vec3 base = mix(groutColor, tileColor, grout);

    ambient = 0.15 * base;
    diffuse = diff * base * uLightColor;
    specular = 0.6 * spec * uLightColor;
    color = ambient + diffuse + specular;
  }

  // shadow calculation
  vec3 proj = vLightSpace.xyz / vLightSpace.w;
  vec2 shadowUV = proj.xy * 0.5 + 0.5;
  float currentDepth = proj.z * 0.5 + 0.5;

  float shadow = 1.0;
  // if inside shadow map area, sample shadow map
  if(shadowUV.x >= 0.0 && shadowUV.x <= 1.0 && shadowUV.y >= 0.0 && shadowUV.y <= 1.0){
    // texel size approximate from texture size (we assume 2048 used, but pass consistent)
    float texel = 1.0 / 2048.0;
    float pcf = sampleShadow(shadowUV, currentDepth, texel);
    // reduce brightness where in shadow; keep some ambient
    shadow = mix(0.35, 1.0, pcf);
  }
  color *= shadow;

  fragColor = vec4(color, 1.0);
}
`;

// compile/link
const progMain = link(compile(vsMain, gl.VERTEX_SHADER), compile(fsMain, gl.FRAGMENT_SHADER));

// ---------- attribute/uniform locations ----------
const locDepth = {
  uModel: gl.getUniformLocation(progDepth, 'uModel'),
  uLightVP: gl.getUniformLocation(progDepth, 'uLightVP')
};

const loc = {
  // attributes are fixed layout locations (0:pos,1:normal,2:uv)
  uModel: gl.getUniformLocation(progMain, 'uModel'),
  uView: gl.getUniformLocation(progMain, 'uView'),
  uProj: gl.getUniformLocation(progMain, 'uProj'),
  uLightVP: gl.getUniformLocation(progMain, 'uLightVP'),
  uLightPos: gl.getUniformLocation(progMain, 'uLightPos'),
  uLightColor: gl.getUniformLocation(progMain, 'uLightColor'),
  uViewPos: gl.getUniformLocation(progMain, 'uViewPos'),
  uBaseColor: gl.getUniformLocation(progMain, 'uBaseColor'),
  uIsFloor: gl.getUniformLocation(progMain, 'uIsFloor'),
  uTileScale: gl.getUniformLocation(progMain, 'uTileScale'),
  uLineWidth: gl.getUniformLocation(progMain, 'uLineWidth'),
  uShadowMap: gl.getUniformLocation(progMain, 'uShadowMap')
};

// ---------- geometry creation ----------
// helper: plane and cube vertices (pos, normal, uv)
function buildCube(s=1){
  const h=s;
  const data = [
    // front face
    -h,-h, h,  0,0,1,  0,0,
     h,-h, h,  0,0,1,  1,0,
     h, h, h,  0,0,1,  1,1,
    -h, h, h,  0,0,1,  0,1,
    // back
     h,-h,-h,  0,0,-1, 0,0,
    -h,-h,-h,  0,0,-1, 1,0,
    -h, h,-h,  0,0,-1, 1,1,
     h, h,-h,  0,0,-1, 0,1,
    // top
    -h, h, h,  0,1,0,  0,0,
     h, h, h,  0,1,0,  1,0,
     h, h,-h,  0,1,0,  1,1,
    -h, h,-h,  0,1,0,  0,1,
    // bottom
    -h,-h,-h,  0,-1,0, 0,0,
     h,-h,-h,  0,-1,0, 1,0,
     h,-h, h,  0,-1,0, 1,1,
    -h,-h, h,  0,-1,0, 0,1,
    // right
     h,-h, h,  1,0,0, 0,0,
     h,-h,-h,  1,0,0, 1,0,
     h, h,-h,  1,0,0, 1,1,
     h, h, h,  1,0,0, 0,1,
    // left
    -h,-h,-h, -1,0,0, 0,0,
    -h,-h, h, -1,0,0, 1,0,
    -h, h, h, -1,0,0, 1,1,
    -h, h,-h, -1,0,0, 0,1
  ];
  const verts = new Float32Array(data);
  const idx = new Uint16Array([
    0,1,2, 0,2,3,
    4,5,6, 4,6,7,
    8,9,10, 8,10,11,
    12,13,14, 12,14,15,
    16,17,18, 16,18,19,
    20,21,22, 20,22,23
  ]);
  return {verts, idx};
}

function buildPlane(size=10){
  const s=size/2;
  const verts = new Float32Array([
    -s,0,-s,   0,1,0,   0,0,
     s,0,-s,   0,1,0,   size,0,
     s,0, s,   0,1,0,   size,size,
    -s,0, s,   0,1,0,   0,size
  ]);
  const idx = new Uint16Array([0,1,2, 0,2,3]);
  return {verts, idx};
}

// build objects
const cubeGeo = buildCube(1.0); // size 2x2 (h=1 means half-extents 1)
const floorGeo = buildPlane(50);
const wallThickness = 0.2;
function buildWall(width, height, depth){
  // create a box geometry manually with uv simple (not needed much)
  const w=width/2, h=height/2, d=depth/2;
  // reuse cube builder but with scale factors
  const arr = [];
  // front face
  arr.push(-w,-h, d, 0,0,1, 0,0,  w,-h, d, 0,0,1, 1,0,  w, h, d,0,0,1,1,1, -w,h,d,0,0,1,0,1);
  // back
  arr.push(w,-h,-d,0,0,-1,0,0, -w,-h,-d,0,0,-1,1,0, -w,h,-d,0,0,-1,1,1, w,h,-d,0,0,-1,0,1);
  // top
  arr.push(-w,h,d,0,1,0,0,0, w,h,d,0,1,0,1,0, w,h,-d,0,1,0,1,1, -w,h,-d,0,1,0,0,1);
  // bottom
  arr.push(-w,-h,-d,0,-1,0,0,0, w,-h,-d,0,-1,0,1,0, w,-h,d,0,-1,0,1,1, -w,-h,d,0,-1,0,0,1);
  // right
  arr.push(w,-h,-d,1,0,0,0,0, w,h,-d,1,0,0,1,0, w,h,d,1,0,0,1,1, w,-h,d,1,0,0,0,1);
  // left
  arr.push(-w,-h,-d,-1,0,0,0,0, -w,-h,d,-1,0,0,1,0, -w,h,d,-1,0,0,1,1, -w,h,-d,-1,0,0,0,1);
  // flatten
  const flat = [];
  for(let block of arr) flat.push(...block);
  // indices
  const idx = new Uint16Array([
    0,1,2, 0,2,3,
    4,5,6, 4,6,7,
    8,9,10, 8,10,11,
    12,13,14, 12,14,15,
    16,17,18, 16,18,19,
    20,21,22, 20,22,23
  ]);
  return {verts:new Float32Array(flat), idx};
}

// create VAO helper
function createVAO(verts, idx){
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idx, gl.STATIC_DRAW);
  const stride = (3+3+2) * 4;
  // pos loc 0
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,3,gl.FLOAT,false,stride,0);
  // normal loc 1
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1,3,gl.FLOAT,false,stride,3*4);
  // uv loc 2
  gl.enableVertexAttribArray(2);
  gl.vertexAttribPointer(2,2,gl.FLOAT,false,stride,(3+3)*4);
  gl.bindVertexArray(null);
  return {vao, count: idx.length};
}

// create VAOs
const cubeObj = createVAO(cubeGeo.verts, cubeGeo.idx);
const planeObj = createVAO(floorGeo.verts, floorGeo.idx);

// walls: four sides
const arenaSize = 20;
const wallH = 2.0;
const wall1Geo = buildWall(arenaSize, wallH, wallThickness);
const wall2Geo = buildWall(arenaSize, wallH, wallThickness);
const wall3Geo = buildWall(wallThickness, wallH, arenaSize);
const wall4Geo = buildWall(wallThickness, wallH, arenaSize);
const wall1Obj = createVAO(wall1Geo.verts, wall1Geo.idx);
const wall2Obj = createVAO(wall2Geo.verts, wall2Geo.idx);
const wall3Obj = createVAO(wall3Geo.verts, wall3Geo.idx);
const wall4Obj = createVAO(wall4Geo.verts, wall4Geo.idx);

// depth-only VAOs (position only) for depth pass (we can reuse same buffers but attribute layout must match depth shader loc0)
function createDepthVAO(verts, idx){
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  const vbo = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
  gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
  const ibo = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idx, gl.STATIC_DRAW);
  // position only (stride 8*4, pos offset 0)
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,3,gl.FLOAT,false,(3+3+2)*4, 0);
  gl.bindVertexArray(null);
  return {vao, count: idx.length};
}
const cubeDepth = createDepthVAO(cubeGeo.verts, cubeGeo.idx);
const planeDepth = createDepthVAO(floorGeo.verts, floorGeo.idx);
const wall1Depth = createDepthVAO(wall1Geo.verts, wall1Geo.idx);
const wall2Depth = createDepthVAO(wall2Geo.verts, wall2Geo.idx);
const wall3Depth = createDepthVAO(wall3Geo.verts, wall3Geo.idx);
const wall4Depth = createDepthVAO(wall4Geo.verts, wall4Geo.idx);

// ---------- shadow framebuffer (depth texture) ----------
const SHADOW_SIZE = 2048;
const depthTex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, depthTex);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.DEPTH_COMPONENT24, SHADOW_SIZE, SHADOW_SIZE, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

const shadowFBO = gl.createFramebuffer();
gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFBO);
gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTex, 0);
gl.drawBuffers([gl.NONE]);
gl.readBuffer(gl.NONE);
if(gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE){
  console.error('Shadow FBO incomplete');
}
gl.bindFramebuffer(gl.FRAMEBUFFER, null);

// ---------- uniforms defaults ----------
gl.useProgram(progMain);
gl.uniform3fv(loc.uLightColor, [1.0,1.0,1.0]);
gl.uniform1i(loc.uShadowMap, 0); // texture unit 0

// ---------- camera/control state ----------
let angle = 0.0, pitch = 0.35, distance = 9.0;
let dragging=false, lastX=0, lastY=0, userOverride=false, overrideUntil=0;
let panX=0, panY=0;
function startUserOverride(){ userOverride=true; overrideUntil = performance.now() + 1800; }
function updateOverride(){ if(userOverride && performance.now() > overrideUntil) userOverride=false; }

// mouse
canvas.addEventListener('mousedown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; startUserOverride(); });
window.addEventListener('mouseup', ()=> dragging=false);
window.addEventListener('mousemove', e=>{
  if(!dragging) return;
  const dx = e.clientX - lastX, dy = e.clientY - lastY;
  angle += dx * 0.006;
  pitch = Math.max(-1.2, Math.min(1.2, pitch + dy*0.006));
  lastX=e.clientX; lastY=e.clientY;
  startUserOverride();
});
// wheel zoom
canvas.addEventListener('wheel', e=>{ distance += e.deltaY * 0.02; distance = Math.max(3, Math.min(50, distance)); startUserOverride(); e.preventDefault(); }, {passive:false});

// touch: drag, pinch, tap
let lastTouchDist = null, tapStart=0, tapX=0, tapY=0;
canvas.addEventListener('touchstart', e=>{
  if(e.touches.length===1){
    tapStart = performance.now(); tapX=e.touches[0].clientX; tapY=e.touches[0].clientY;
    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
  } else if(e.touches.length===2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    lastTouchDist = Math.hypot(dx,dy);
  }
  startUserOverride();
}, {passive:true});
canvas.addEventListener('touchmove', e=>{
  if(e.touches.length===1){
    const dx = e.touches[0].clientX - lastX;
    const dy = e.touches[0].clientY - lastY;
    angle += dx * 0.01;
    pitch = Math.max(-1.2, Math.min(1.2, pitch + dy*0.01));
    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
  } else if(e.touches.length===2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const d = Math.hypot(dx,dy);
    if(lastTouchDist){
      distance *= lastTouchDist / d;
      distance = Math.max(3, Math.min(50, distance));
    }
    lastTouchDist = d;
  }
  startUserOverride();
}, {passive:true});
canvas.addEventListener('touchend', e=>{
  if(e.changedTouches && e.changedTouches.length>0){
    const dt = performance.now() - tapStart;
    const dx = e.changedTouches[0].clientX - tapX;
    const dy = e.changedTouches[0].clientY - tapY;
    if(dt < 220 && Math.hypot(dx,dy) < 12){
      // tap -> random cube color
      cubeColor = [Math.random()*0.9+0.05, Math.random()*0.9+0.05, Math.random()*0.9+0.05];
    }
  }
  lastTouchDist = null;
});

// keyboard pan
window.addEventListener('keydown', e=>{
  const step = 0.3;
  if(e.key === 'ArrowLeft') panX -= step;
  if(e.key === 'ArrowRight') panX += step;
  if(e.key === 'ArrowUp') panY += step;
  if(e.key === 'ArrowDown') panY -= step;
  startUserOverride();
});

// ---------- simple math helpers ----------
function normalize(v){ const L = Math.hypot(v[0],v[1],v[2])||1; return [v[0]/L,v[1]/L,v[2]/L]; }
function cross(a,b){ return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
function dot(a,b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }

// build lookAt (column-major for glUniformMatrix4fv)
function buildLookAt(eye, center, up){
  const f = normalize([center[0]-eye[0], center[1]-eye[1], center[2]-eye[2]]);
  const s = normalize(cross(f, up));
  const u = cross(s, f);
  return new Float32Array([
    s[0], u[0], -f[0], 0,
    s[1], u[1], -f[1], 0,
    s[2], u[2], -f[2], 0,
    -dot(s, eye), -dot(u, eye), dot(f, eye), 1
  ]);
}
function perspective(fovy, aspect, near, far){
  const f = 1.0/Math.tan(fovy/2);
  const nf = 1/(near - far);
  const out = new Float32Array(16);
  out[0] = f / aspect; out[1]=0; out[2]=0; out[3]=0;
  out[4] = 0; out[5]=f; out[6]=0; out[7]=0;
  out[8]=0; out[9]=0; out[10]=(far+near)*nf; out[11]=-1;
  out[12]=0; out[13]=0; out[14]=(2*far*near)*nf; out[15]=0;
  return out;
}

// ---------- material/state ----------
let cubeColor = [0.45, 0.8, 0.95];

// ---------- utility: set model matrix from transforms ----------
function identityMat(){ return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }
function translateMat(m, v){
  const out = new Float32Array(m);
  out[12] += v[0]; out[13] += v[1]; out[14] += v[2];
  return out;
}
function rotateYMat(m, rad){
  const c=Math.cos(rad), s=Math.sin(rad);
  const r = new Float32Array([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]);
  // out = r * m
  const out = new Float32Array(16);
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      let s=0;
      for(let k=0;k<4;k++) s += r[k*4 + j] * m[i*4 + k];
      out[i*4 + j] = s;
    }
  }
  return out;
}
function rotateXMat(m, rad){
  const c=Math.cos(rad), s=Math.sin(rad);
  const r = new Float32Array([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]);
  const out = new Float32Array(16);
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      let s=0;
      for(let k=0;k<4;k++) s += r[k*4 + j] * m[i*4 + k];
      out[i*4 + j] = s;
    }
  }
  return out;
}
function scaleMat(m, v){
  const out = new Float32Array(m);
  out[0]*=v[0]; out[1]*=v[0]; out[2]*=v[0]; out[3]*=v[0];
  out[4]*=v[1]; out[5]*=v[1]; out[6]*=v[1]; out[7]*=v[1];
  out[8]*=v[2]; out[9]*=v[2]; out[10]*=v[2]; out[11]*=v[2];
  return out;
}

// ---------- render loop (two passes) ----------
gl.enable(gl.DEPTH_TEST);
gl.enable(gl.CULL_FACE);

function computeLightVP(lightPos){
  // simple ortho projection for directional-like light
  const center = [0, 0.5, 0];
  // lookAt matrix for light
  const up = [0,1,0];
  const view = buildLookAt(lightPos, center, up);
  // orthographic projection
  const s = 20.0;
  // build ortho matrix column-major
  const left = -s, right = s, bottom = -s, top = s, near = 0.5, far = 60.0;
  const ortho = new Float32Array(16);
  ortho[0] = 2/(right-left); ortho[5] = 2/(top-bottom); ortho[10] = -2/(far-near);
  ortho[12] = -(right+left)/(right-left); ortho[13] = -(top+bottom)/(top-bottom); ortho[14] = -(far+near)/(far-near); ortho[15]=1;
  // multiply ortho * view
  // Both are column-major; compute out = ortho * view
  const out = new Float32Array(16);
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      let ssum = 0;
      for(let k=0;k<4;k++){
        ssum += ortho[k*4 + j] * view[i*4 + k];
      }
      out[i*4 + j] = ssum;
    }
  }
  return out;
}

function setUniformsCommon(viewMat, projMat, lightVP, lightPos, viewPos){
  gl.useProgram(progMain);
  gl.uniformMatrix4fv(loc.uView, false, viewMat);
  gl.uniformMatrix4fv(loc.uProj, false, projMat);
  gl.uniformMatrix4fv(loc.uLightVP, false, lightVP);
  gl.uniform3fv(loc.uLightPos, lightPos);
  gl.uniform3fv(loc.uLightColor, [1,1,1]);
  gl.uniform3fv(loc.uViewPos, viewPos);
}

function drawDepthPass(lightVP){
  gl.useProgram(progDepth);
  gl.bindFramebuffer(gl.FRAMEBUFFER, shadowFBO);
  gl.viewport(0,0,SHADOW_SIZE,SHADOW_SIZE);
  gl.clear(gl.DEPTH_BUFFER_BIT);
  // no color writes
  gl.colorMask(false,false,false,false);

  // cube depth
  let model = identityMat();
  model = translateMat(model, [0, 2.0, 0]); // cube higher
  model = rotateYMat(model, tNow * 0.9);
  gl.uniformMatrix4fv(locDepth.uModel, false, model);
  gl.uniformMatrix4fv(locDepth.uLightVP, false, lightVP);
  gl.bindVertexArray(cubeDepth.vao);
  gl.drawElements(gl.TRIANGLES, cubeDepth.count, gl.UNSIGNED_SHORT, 0);

  // plane depth
  model = identityMat();
  model = translateMat(model, [0, -0.5, 0]); // lowered floor
  gl.uniformMatrix4fv(locDepth.uModel, false, model);
  gl.bindVertexArray(planeDepth.vao);
  gl.drawElements(gl.TRIANGLES, planeDepth.count, gl.UNSIGNED_SHORT, 0);

  // walls depth
  model = identityMat(); model = translateMat(model, [0, wallH/2, -arenaSize/2]); gl.uniformMatrix4fv(locDepth.uModel, false, model);
  gl.bindVertexArray(wall1Depth.vao); gl.drawElements(gl.TRIANGLES, wall1Depth.count, gl.UNSIGNED_SHORT, 0);
  model = identityMat(); model = translateMat(model, [0, wallH/2, arenaSize/2]); gl.uniformMatrix4fv(locDepth.uModel, false, model);
  gl.bindVertexArray(wall2Depth.vao); gl.drawElements(gl.TRIANGLES, wall2Depth.count, gl.UNSIGNED_SHORT, 0);
  model = identityMat(); model = translateMat(model, [-arenaSize/2, wallH/2, 0]); gl.uniformMatrix4fv(locDepth.uModel, false, model);
  gl.bindVertexArray(wall3Depth.vao); gl.drawElements(gl.TRIANGLES, wall3Depth.count, gl.UNSIGNED_SHORT, 0);
  model = identityMat(); model = translateMat(model, [arenaSize/2, wallH/2, 0]); gl.uniformMatrix4fv(locDepth.uModel, false, model);
  gl.bindVertexArray(wall4Depth.vao); gl.drawElements(gl.TRIANGLES, wall4Depth.count, gl.UNSIGNED_SHORT, 0);

  // restore
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.colorMask(true,true,true,true);
  gl.viewport(0,0,canvas.width, canvas.height);
}

let lastTime = 0;
let tNow = 0;

function renderFrame(time){
  resize();
  tNow = time * 0.001;
  updateOverride();

  // auto-rotate if not user override
  if(!userOverride) angle += 0.3 * 0.01;

  // compute camera world pos (spherical)
  const cx = panX + Math.sin(angle) * distance * Math.cos(pitch);
  const cy = panY + Math.sin(pitch) * distance + 1.4;
  const cz = panX + Math.cos(angle) * distance * Math.cos(pitch);
  const viewMat = buildLookAt([cx,cy,cz], [panX, 0.8, panX], [0,1,0]);
  const projMat = perspective(Math.PI/3, canvas.width/canvas.height, 0.1, 200.0);

  // compute light VP
  const lightPos = [8.0, 12.0, 6.0];
  const lightVP = computeLightVP(lightPos);

  // 1) depth pass
  drawDepthPass(lightVP);

  // 2) main pass
  gl.useProgram(progMain);
  gl.viewport(0,0,canvas.width, canvas.height);
  gl.clearColor(0.53,0.75,0.95,1.0); // sky background (different from floor)
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // set uniforms
  setUniformsCommon(viewMat, projMat, lightVP, lightPos, [cx,cy,cz]);

  // bind shadow map to unit 0
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, depthTex);
  gl.uniform1i(loc.uShadowMap, 0);

  // draw floor
  gl.bindVertexArray(planeObj.vao);
  let model = identityMat();
  model = translateMat(model, [0,-0.5,0]); // lower
  gl.uniformMatrix4fv(loc.uModel, false, model);
  gl.uniform1i(loc.uIsFloor, 1);
  gl.uniform1f(loc.uTileScale, 24.0); // many tiles -> infinite feel
  gl.uniform1f(loc.uLineWidth, 0.04);  // thicker grout
  gl.uniform3fv(loc.uBaseColor, [1.0,1.0,1.0]);
  gl.drawElements(gl.TRIANGLES, planeObj.count, gl.UNSIGNED_SHORT, 0);

  // draw walls (transparent)
  gl.bindVertexArray(wall1Obj.vao);
  model = identityMat(); model = translateMat(model, [0, wallH/2, -arenaSize/2]);
  gl.uniformMatrix4fv(loc.uModel, false, model);
  gl.uniform1i(loc.uIsFloor, 0);
  gl.uniform3fv(loc.uBaseColor, [0.9,0.9,0.95]);
  gl.drawElements(gl.TRIANGLES, wall1Obj.count, gl.UNSIGNED_SHORT, 0);

  gl.bindVertexArray(wall2Obj.vao);
  model = identityMat(); model = translateMat(model, [0, wallH/2, arenaSize/2]);
  gl.uniformMatrix4fv(loc.uModel, false, model);
  gl.drawElements(gl.TRIANGLES, wall2Obj.count, gl.UNSIGNED_SHORT, 0);

  gl.bindVertexArray(wall3Obj.vao);
  model = identityMat(); model = translateMat(model, [-arenaSize/2, wallH/2, 0]);
  gl.uniformMatrix4fv(loc.uModel, false, model);
  gl.drawElements(gl.TRIANGLES, wall3Obj.count, gl.UNSIGNED_SHORT, 0);

  gl.bindVertexArray(wall4Obj.vao);
  model = identityMat(); model = translateMat(model, [arenaSize/2, wallH/2, 0]);
  gl.uniformMatrix4fv(loc.uModel, false, model);
  gl.drawElements(gl.TRIANGLES, wall4Obj.count, gl.UNSIGNED_SHORT, 0);

  // draw cube (rotating & floating)
  gl.bindVertexArray(cubeObj.vao);
  model = identityMat();
  const floatY = 2.0 + Math.sin(tNow * 2.0) * 0.25;
  model = translateMat(model, [0, floatY, 0]);
  model = rotateYMat(model, tNow * 0.9);
  model = rotateXMat(model, tNow * 0.6);
  gl.uniformMatrix4fv(loc.uModel, false, model);
  gl.uniform1i(loc.uIsFloor, 0);
  gl.uniform3fv(loc.uBaseColor, cubeColor);
  gl.drawElements(gl.TRIANGLES, cubeObj.count, gl.UNSIGNED_SHORT, 0);

  requestAnimationFrame(renderFrame);
}

requestAnimationFrame(renderFrame);

// ---------- done ----------
console.log('Scene initialized (shadow mapping, tiles, walls).');

</script>
</body>
</html>
