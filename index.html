<!DOCTYPE html>
<html lang="id">
<head>
<meta charset="utf-8">
<title>Cube + Grid Floor + Orbit Camera</title>
<style>
html,body {margin:0;padding:0;width:100%;height:100%;background:#fff;}
canvas{display:block;width:100%;height:100vh;}
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
// ---------------- Matrix & Vector Helper ----------------
function degToRad(d){return d*Math.PI/180;}
function identity(){return [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];}
function multiply(a,b){
  let out=new Array(16);
  for(let i=0;i<4;i++){
    for(let j=0;j<4;j++){
      let s=0;
      for(let k=0;k<4;k++) s+=a[k*4+j]*b[i*4+k];
      out[i*4+j]=s;
    }
  }
  return out;
}
function translate(m,v){
  const [x,y,z]=v;
  let out=m.slice();
  out[12]=m[0]*x+m[4]*y+m[8]*z+m[12];
  out[13]=m[1]*x+m[5]*y+m[9]*z+m[13];
  out[14]=m[2]*x+m[6]*y+m[10]*z+m[14];
  out[15]=m[3]*x+m[7]*y+m[11]*z+m[15];
  return out;
}
function rotateX(m,r){const c=Math.cos(r),s=Math.sin(r),rm=[1,0,0,0,0,c,s,0,0,-s,c,0,0,0,0,1];return multiply(rm,m);}
function rotateY(m,r){const c=Math.cos(r),s=Math.sin(r),rm=[c,0,-s,0,0,1,0,0,s,0,c,0,0,0,0,1];return multiply(rm,m);}
function scale(m,v){const [x,y,z]=v;let out=m.slice();out[0]*=x;out[1]*=x;out[2]*=x;out[3]*=x;out[4]*=y;out[5]*=y;out[6]*=y;out[7]*=y;out[8]*=z;out[9]*=z;out[10]*=z;out[11]*=z;return out;}
function perspective(fovy,aspect,near,far){const f=1.0/Math.tan(fovy/2),nf=1/(near-far);let out=new Array(16).fill(0);out[0]=f/aspect;out[5]=f;out[10]=(far+near)*nf;out[11]=-1;out[14]=2*far*near*nf;return out;}
function subtract(a,b){return[a[0]-b[0],a[1]-b[1],a[2]-b[2]];}
function cross(a,b){return[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];}
function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}
function normalize(v){const l=Math.sqrt(dot(v,v))||1;return[v[0]/l,v[1]/l,v[2]/l];}

// ---------------- WebGL Setup ----------------
const canvas=document.getElementById('glcanvas');
const gl=canvas.getContext('webgl',{antialias:true});
if(!gl)throw new Error("WebGL tidak tersedia");
function resizeCanvas(){const dpr=window.devicePixelRatio||1,w=Math.floor(canvas.clientWidth*dpr),h=Math.floor(canvas.clientHeight*dpr);if(canvas.width!==w||canvas.height!==h){canvas.width=w;canvas.height=h;gl.viewport(0,0,w,h);}}
window.addEventListener('resize',resizeCanvas);resizeCanvas();
gl.enable(gl.DEPTH_TEST);
gl.enable(gl.CULL_FACE);
gl.clearColor(1,1,1,1);

// ---------------- Shaders ----------------
const vs=`attribute vec3 aPos;attribute vec3 aNormal;attribute vec2 aUV;uniform mat4 uModel,uView,uProj;varying vec3 vNormal,vPos;varying vec2 vUV;void main(){vec4 worldPos=uModel*vec4(aPos,1.0);vPos=worldPos.xyz;vNormal=mat3(uModel)*aNormal;vUV=aUV;gl_Position=uProj*uView*worldPos;}`;
const fs=`precision mediump float;varying vec3 vNormal,vPos;varying vec2 vUV;uniform vec3 uLightDir,uLightColor,uAmbient,uBaseColor;uniform float uCheckerScale;uniform int uIsFloor;void main(){vec3 N=normalize(vNormal);vec3 L=normalize(uLightDir);float diff=max(dot(N,L),0.0);vec3 base=uBaseColor;if(uIsFloor==1){vec2 st=vUV*uCheckerScale;vec2 f=fract(st);float lw=0.03;float ax=smoothstep(0.0,lw,f.x)*(1.0-smoothstep(1.0-lw,1.0,f.x));float ay=smoothstep(0.0,lw,f.y)*(1.0-smoothstep(1.0-lw,1.0,f.y));float line=1.0-min(1.0,ax+ay);vec3 tile=vec3(1.0);vec3 grout=vec3(0.0);base=mix(grout,tile,line);}vec3 col=uAmbient*base+diff*uLightColor*base;gl_FragColor=vec4(col,1.0);`;
function compileShader(src,type){const s=gl.createShader(type);gl.shaderSource(s,src);gl.compileShader(s);if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){console.error(gl.getShaderInfoLog(s));throw new Error("Shader error");}return s;}
function createProgram(vs,fs){const p=gl.createProgram();gl.attachShader(p,compileShader(vs,gl.VERTEX_SHADER));gl.attachShader(p,compileShader(fs,gl.FRAGMENT_SHADER));gl.linkProgram(p);if(!gl.getProgramParameter(p,gl.LINK_STATUS)){console.error(gl.getProgramInfoLog(p));throw new Error("Program link error");}return p;}
const program=createProgram(vs,fs);
gl.useProgram(program);
const attribs={pos:gl.getAttribLocation(program,'aPos'),normal:gl.getAttribLocation(program,'aNormal'),uv:gl.getAttribLocation(program,'aUV')};
const uniforms={
  uModel:gl.getUniformLocation(program,'uModel'),
  uView:gl.getUniformLocation(program,'uView'),
  uProj:gl.getUniformLocation(program,'uProj'),
  uLightDir:gl.getUniformLocation(program,'uLightDir'),
  uLightColor:gl.getUniformLocation(program,'uLightColor'),
  uAmbient:gl.getUniformLocation(program,'uAmbient'),
  uBaseColor:gl.getUniformLocation(program,'uBaseColor'),
  uCheckerScale:gl.getUniformLocation(program,'uCheckerScale'),
  uIsFloor:gl.getUniformLocation(program,'uIsFloor')
};

// ---------------- Geometry ----------------
function makeCube(s=1){
  const h=s/2;
  const pos=[-h,-h,h,h,-h,h,h,h,h,-h,h,h,h,h,-h,-h,-h,-h,-h,h,-h,h,h,h,h,-h,h,-h,h,-h,-h,-h,h,-h,h,h,h,h,h,-h,-h,-h,h,-h,-h,h,h,h,-h,h,-h,h,-h,h];
  const norm=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,-1,0,0,-1,0,0,-1,0,0,-1,1,0,1,0,1,0,1,0,1,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1];
  const uv=[0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0,0,1,0,1,1,0,1];
  const idx=[];
  for(let f=0;f<6;f++){let b=f*4;idx.push(b,b+1,b+2,b,b+2,b+3);}
  return {positions:pos,normals:norm,uvs:uv,indices:idx};
}
function makeFloor(size=20){
  const h=size/2;
  return {positions:[-h,0,-h,h,0,-h,h,0,h,-h,0,h],normals:[0,1,0,0,1,0,0,1,0,0,1,0],uvs:[0,0,size,0,size,size,0,size],indices:[0,1,2,0,2,3]};
}
function createVAO(geom){
  const vao={};
  function buf(data,itemSize,attrib){
    const b=gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER,b);
    gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(data),gl.STATIC_DRAW);
    if(attrib>=0){gl.enableVertexAttribArray(attrib);gl.vertexAttribPointer(attrib,itemSize,gl.FLOAT,false,0,0);}
    return b;
  }
  vao.pos=buf(geom.positions,3,attribs.pos);
  vao.norm=buf(geom.normals,3,attribs.normal);
  vao.uv=buf(geom.uvs,2,attribs.uv);
  vao.idx=gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,vao.idx);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(geom.indices),gl.STATIC_DRAW);
  vao.count=geom.indices.length;
  return vao;
}
const cubeVAO=createVAO(makeCube(1.5));
const floorVAO=createVAO(makeFloor(20));

// ---------------- Camera ----------------
let angleX=0,angleY=0,distance=6,drag=false,lastX=0,lastY=0;
canvas.addEventListener('mousedown',e=>{drag=true;lastX=e.clientX;lastY=e.clientY;});
canvas.addEventListener('mousemove',e=>{if(drag){angleY+=(e.clientX-lastX)*0.01;angleX+=(e.clientY-lastY)*0.01;angleX=Math.max(-Math.PI/2,Math.min(Math.PI/2,angleX));lastX=e.clientX;lastY=e.clientY;}});
canvas.addEventListener('mouseup',()=>{drag=false;});
canvas.addEventListener('mouseleave',()=>{drag=false;});
canvas.addEventListener('wheel',e=>{distance+=e.deltaY*0.01;distance=Math.max(2,Math.min(20,distance));});

// ---------------- LookAt ----------------
function lookAt(eye,target,up=[0,1,0]){
  const z=normalize(subtract(eye,target));
  const x=normalize(cross(up,z));
  const y=cross(z,x);
  return [x[0],y[0],z[0],0,x[1],y[1],z[1],0,x[2],y[2],z[2],0,-dot(x,eye),-dot(y,eye),-dot(z,eye),1];
}

// ---------------- Render ----------------
let last=0,cubeAngle=0;
function render(t){
  t*=0.001;
  const delta=t-last;last=t;
  cubeAngle+=delta;
  resizeCanvas();
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  const aspect=canvas.width/canvas.height;
  const proj=perspective(Math.PI/4,aspect,0.1,100);
  const camPos=[Math.sin(angleY)*Math.cos(angleX)*distance,Math.sin(angleX)*distance,Math.cos(angleY)*Math.cos(angleX)*distance];
  const view=lookAt(camPos,[0,0.8,0]);
  gl.uniformMatrix4fv(uniforms.uView,false,new Float32Array(view));
  gl.uniformMatrix4fv(uniforms.uProj,false,new Float32Array(proj));
  gl.uniform3fv(uniforms.uLightDir,normalize([0.5,1,0.3]));
  gl.uniform3fv(uniforms.uLightColor,[1,1,1]);
  gl.uniform3fv(uniforms.uAmbient,[0.3,0.3,0.3]);

  // Floor
  gl.bindBuffer(gl.ARRAY_BUFFER,floorVAO.pos);gl.vertexAttribPointer(attribs.pos,3,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ARRAY_BUFFER,floorVAO.norm);gl.vertexAttribPointer(attribs.normal,3,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ARRAY_BUFFER,floorVAO.uv);gl.vertexAttribPointer(attribs.uv,2,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,floorVAO.idx);
  let model=identity();
  gl.uniformMatrix4fv(uniforms.uModel,false,new Float32Array(model));
  gl.uniform3fv(uniforms.uBaseColor,[1,1,1]);
  gl.uniform1f(uniforms.uCheckerScale,10.0);
  gl.uniform1i(uniforms.uIsFloor,1);
  gl.drawElements(gl.TRIANGLES,floorVAO.count,gl.UNSIGNED_SHORT,0);

  // Cube
  gl.bindBuffer(gl.ARRAY_BUFFER,cubeVAO.pos);gl.vertexAttribPointer(attribs.pos,3,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ARRAY_BUFFER,cubeVAO.norm);gl.vertexAttribPointer(attribs.normal,3,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ARRAY_BUFFER,cubeVAO.uv);gl.vertexAttribPointer(attribs.uv,2,gl.FLOAT,false,0,0);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,cubeVAO.idx);
  model=identity();model=translate(model,[0,0.8,0]);model=rotateY(model,cubeAngle);model=rotateX(model,cubeAngle*0.5);
  gl.uniformMatrix4fv(uniforms.uModel,false,new Float32Array(model));
  gl.uniform3fv(uniforms.uBaseColor,[0.8,0.2,0.2]);
  gl.uniform1i(uniforms.uIsFloor,0);
  gl.drawElements(gl.TRIANGLES,cubeVAO.count,gl.UNSIGNED_SHORT,0);

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>
