<!doctype html>
<html lang="id">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Modern WebGL2 Cube — Phong + Texture + Orbit</title>
<link rel="icon" href="data:,">
<style>
  :root{--ui-bg:rgba(10,10,12,0.72);--accent:#6EE7B7}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b1020 0%, #081018 100%);font-family:Inter, system-ui, sans-serif;color:#ddd}
  #wrap{position:fixed;inset:0;display:grid;place-items:center}
  canvas{display:block; width:100vw; height:100vh; touch-action: none; }
  .ui {
    position:fixed; left:12px; top:12px; background:var(--ui-bg); padding:10px 12px; border-radius:10px; backdrop-filter: blur(6px);
    box-shadow: 0 6px 18px rgba(0,0,0,0.6); font-size:13px;
  }
  .ui label{display:flex;gap:8px;align-items:center}
  .ui .row{display:flex;gap:8px;align-items:center;margin-bottom:6px}
  .slider{width:140px}
  .small{font-size:12px;color:#bbb}
  .credits{position:fixed;right:12px;bottom:12px;color:#9aa; font-size:12px}
  button.toggle{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 10px;border-radius:8px;color:#ddd;cursor:pointer}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="gl"></canvas>
  <div class="ui" id="ui">
    <div class="row"><strong>Modern Cube</strong><span class="small">WebGL2 • Phong</span></div>
    <div class="row"><label>Shininess <input id="shin" class="slider" type="range" min="2" max="256" value="64"></label><span id="sval" class="small">64</span></div>
    <div class="row"><label>Light Intensity <input id="lint" class="slider" type="range" min="0" max="6" step="0.1" value="1.5"></label><span id="lintv" class="small">1.5</span></div>
    <div class="row"><label><input id="texToggle" type="checkbox" checked> Use Texture</label></div>
    <div class="row"><button id="reset" class="toggle">Reset View</button></div>
  </div>
  <div class="credits">Drag / touch-drag to orbit • Pinch to zoom • Scroll to zoom</div>
</div>

<!-- gl-matrix -->
<script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.5.0/gl-matrix-min.js"></script>

<script type="module">
const { mat4, mat3, vec3 } = glMatrix;
const canvas = document.getElementById('gl');
const gl = canvas.getContext('webgl2', { antialias: true, alpha: false });
if (!gl) {
  document.body.innerHTML = '<h2 style="color:#fff;padding:20px">Browser tidak mendukung WebGL2</h2>';
  throw new Error('No WebGL2');
}

// DPI-aware resize
function resizeCanvas() {
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const w = Math.floor(canvas.clientWidth * dpr);
  const h = Math.floor(canvas.clientHeight * dpr);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w; canvas.height = h;
  }
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Shaders (WebGL2 / GLSL ES 3.00)
const vs = `#version 300 es
layout(location=0) in vec3 aPos;
layout(location=1) in vec3 aNormal;
layout(location=2) in vec2 aUv;

uniform mat4 uModel;
uniform mat4 uView;
uniform mat4 uProj;
uniform mat3 uNormalMat;

out vec3 vNormal;
out vec3 vWorld;
out vec2 vUv;

void main(){
  vec4 worldPos = uModel * vec4(aPos,1.0);
  vWorld = worldPos.xyz;
  vNormal = normalize(uNormalMat * aNormal);
  vUv = aUv;
  gl_Position = uProj * uView * worldPos;
}
`;

const fs = `#version 300 es
precision highp float;

in vec3 vNormal;
in vec3 vWorld;
in vec2 vUv;
out vec4 frag;

uniform vec3 uLightPos;
uniform vec3 uViewPos;
uniform float uLightIntensity;
uniform float uShininess;
uniform sampler2D uAlbedo;
uniform float uUseTex;
uniform vec3 uBaseColor;

vec3 ACESFilm(vec3 x){
  // simple tonemap-ish (soft)
  x = max(vec3(0.0), x - 0.004);
  return (x*(6.2*x+0.5))/(x*(6.2*x+1.7)+0.06);
}

void main(){
  vec3 N = normalize(vNormal);
  vec3 L = normalize(uLightPos - vWorld);
  vec3 V = normalize(uViewPos - vWorld);
  vec3 H = normalize(L+V);

  // albedo
  vec3 albedo = uBaseColor;
  if(uUseTex > 0.5) albedo *= texture(uAlbedo, vUv).rgb;

  // ambient + ao(approx)
  vec3 ambient = 0.08 * albedo;

  // diffuse
  float diff = max(dot(N, L), 0.0);
  vec3 diffuse = diff * albedo;

  // specular (Blinn)
  float spec = pow(max(dot(N,H), 0.0), uShininess);
  vec3 specColor = vec3(1.0) * spec;

  // rim / fresnel subtle
  float rim = pow(1.0 - max(dot(V,N),0.0), 3.0);

  vec3 color = ambient + (diffuse + specColor) * uLightIntensity + rim * 0.04;

  // simple tonemap + gamma
  color = ACESFilm(color);
  color = pow(color, vec3(1.0/2.2));

  frag = vec4(color, 1.0);
}
`;

// Compile helpers
function compile(src, type) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
    throw new Error('Shader compile error');
  }
  return s;
}
function link(vsSrc, fsSrc) {
  const p = gl.createProgram();
  gl.attachShader(p, compile(vsSrc, gl.VERTEX_SHADER));
  gl.attachShader(p, compile(fsSrc, gl.FRAGMENT_SHADER));
  gl.linkProgram(p);
  if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(p));
    throw new Error('Program link error');
  }
  return p;
}

const program = link(vs, fs);
gl.useProgram(program);

// Cube geometry (positions, normals, uvs, indices)
function makeCube() {
  // 24 vertices (4 per face) with normals and uvs
  const P = [
    // +Z front
    -1,-1, 1,  1,-1, 1,  1,1,1,  -1,1,1,
    // -Z back
    1,-1,-1,  -1,-1,-1,  -1,1,-1,  1,1,-1,
    // +Y top
    -1,1,1,  1,1,1,  1,1,-1,  -1,1,-1,
    // -Y bottom
    -1,-1,-1,  1,-1,-1,  1,-1,1,  -1,-1,1,
    // +X right
    1,-1,1,  1,-1,-1,  1,1,-1,  1,1,1,
    // -X left
    -1,-1,-1,  -1,-1,1,  -1,1,1,  -1,1,-1
  ];
  const N = [
    // front
    0,0,1, 0,0,1, 0,0,1, 0,0,1,
    // back
    0,0,-1, 0,0,-1, 0,0,-1, 0,0,-1,
    // top
    0,1,0, 0,1,0, 0,1,0, 0,1,0,
    // bottom
    0,-1,0, 0,-1,0, 0,-1,0, 0,-1,0,
    // right
    1,0,0, 1,0,0, 1,0,0, 1,0,0,
    // left
    -1,0,0, -1,0,0, -1,0,0, -1,0,0
  ];
  const UV = [
    0,0, 1,0, 1,1, 0,1,
    0,0, 1,0, 1,1, 0,1,
    0,0, 1,0, 1,1, 0,1,
    0,0, 1,0, 1,1, 0,1,
    0,0, 1,0, 1,1, 0,1,
    0,0, 1,0, 1,1, 0,1
  ];
  const I = [
    0,1,2, 0,2,3,
    4,5,6, 4,6,7,
    8,9,10, 8,10,11,
    12,13,14, 12,14,15,
    16,17,18, 16,18,19,
    20,21,22, 20,22,23
  ];
  return { positions: new Float32Array(P), normals: new Float32Array(N), uvs: new Float32Array(UV), indices: new Uint16Array(I) };
}

const geo = makeCube();
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

// position loc=0
const posBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
gl.bufferData(gl.ARRAY_BUFFER, geo.positions, gl.STATIC_DRAW);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

// normal loc=1
const nBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, nBuf);
gl.bufferData(gl.ARRAY_BUFFER, geo.normals, gl.STATIC_DRAW);
gl.enableVertexAttribArray(1);
gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

// uv loc=2
const uvBuf = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, uvBuf);
gl.bufferData(gl.ARRAY_BUFFER, geo.uvs, gl.STATIC_DRAW);
gl.enableVertexAttribArray(2);
gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);

// index
const ibo = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geo.indices, gl.STATIC_DRAW);

gl.bindVertexArray(null);

// Create checkerboard texture (self-contained)
function createChecker(size=512, squares=16) {
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');
  const s = size / squares;
  for(let y=0;y<squares;y++){
    for(let x=0;x<squares;x++){
      ctx.fillStyle = ((x+y)&1) ? '#1f2b6b' : '#e7eef6';
      ctx.fillRect(x*s,y*s,s,s);
    }
  }
  // soft vignette
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = '#000';
  ctx.beginPath(); ctx.arc(size*0.5,size*0.5,size*0.6,0,Math.PI*2); ctx.fill();
  return c;
}
const tex = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, tex);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, createChecker(512, 16));
gl.generateMipmap(gl.TEXTURE_2D);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
gl.bindTexture(gl.TEXTURE_2D, null);

// Uniform locations
const locs = {
  uModel: gl.getUniformLocation(program, 'uModel'),
  uView: gl.getUniformLocation(program, 'uView'),
  uProj: gl.getUniformLocation(program, 'uProj'),
  uNormalMat: gl.getUniformLocation(program, 'uNormalMat'),
  uLightPos: gl.getUniformLocation(program, 'uLightPos'),
  uViewPos: gl.getUniformLocation(program, 'uViewPos'),
  uLightIntensity: gl.getUniformLocation(program, 'uLightIntensity'),
  uShininess: gl.getUniformLocation(program, 'uShininess'),
  uAlbedo: gl.getUniformLocation(program, 'uAlbedo'),
  uUseTex: gl.getUniformLocation(program, 'uUseTex'),
  uBaseColor: gl.getUniformLocation(program, 'uBaseColor'),
};

// Camera / transform state (orbit)
let radius = 4.5;
let theta = Math.PI * 0.25; // azimuth
let phi = Math.PI * 0.35;   // elevation
let isDown = false, lastX=0,lastY=0;
function toVec3FromSpherical(r, th, ph){
  return [ r * Math.sin(ph) * Math.cos(th), r * Math.cos(ph), r * Math.sin(ph) * Math.sin(th) ];
}

// pointer & touch handlers (orbit + pinch)
canvas.addEventListener('pointerdown', (e)=>{
  isDown = true; lastX = e.clientX; lastY = e.clientY; canvas.setPointerCapture(e.pointerId);
});
canvas.addEventListener('pointerup', (e)=> { isDown=false; canvas.releasePointerCapture(e.pointerId); });
canvas.addEventListener('pointermove', (e)=>{
  if(!isDown) return;
  const dx = e.clientX - lastX, dy = e.clientY - lastY;
  lastX = e.clientX; lastY = e.clientY;
  theta -= dx * 0.005;
  phi = Math.min(Math.max(0.08, phi - dy * 0.005), Math.PI - 0.08);
});
canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); radius = Math.max(2.0, Math.min(12.0, radius + e.deltaY*0.01)); }, { passive:false });

// touch pinch for mobile
let ongoing = {};
canvas.addEventListener('touchstart', (e)=>{
  if (e.touches.length === 2) {
    ongoing.dist = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
  } else if (e.touches.length === 1) {
    isDown = true; lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
  }
});
canvas.addEventListener('touchmove', (e)=>{
  e.preventDefault();
  if (e.touches.length === 2) {
    const d = Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY);
    const diff = d - (ongoing.dist||d);
    radius = Math.max(2.0, Math.min(12.0, radius - diff*0.01));
    ongoing.dist = d;
  } else if (e.touches.length === 1 && isDown) {
    const dx = e.touches[0].clientX - lastX, dy = e.touches[0].clientY - lastY;
    lastX = e.touches[0].clientX; lastY = e.touches[0].clientY;
    theta -= dx * 0.005; phi = Math.min(Math.max(0.08, phi - dy * 0.005), Math.PI - 0.08);
  }
}, { passive:false });
canvas.addEventListener('touchend', (e)=>{ if (e.touches.length===0) { isDown=false; ongoing={}; } });

// UI bindings
const shin = document.getElementById('shin');
const sval = document.getElementById('sval');
const lint = document.getElementById('lint');
const lintv = document.getElementById('lintv');
const texToggle = document.getElementById('texToggle');
const reset = document.getElementById('reset');

shin.addEventListener('input', ()=> sval.textContent = shin.value);
lint.addEventListener('input', ()=> lintv.textContent = lint.value);
reset.addEventListener('click', ()=> { radius=4.5; theta=Math.PI*0.25; phi=Math.PI*0.35; });

// Render loop
gl.enable(gl.DEPTH_TEST);
gl.enable(gl.CULL_FACE);

function getProjectionMatrix(aspect) {
  const fovy = Math.PI/4;
  const near = 0.1, far = 100.0;
  const out = mat4.create();
  mat4.perspective(out, fovy, aspect, near, far);
  return out;
}

let t0 = 0;
function frame(t){
  resizeCanvas();
  t *= 0.001;
  const dt = t - t0; t0 = t;

  // camera pos
  const eye = toVec3FromSpherical(radius, theta, phi);
  const view = mat4.create();
  mat4.lookAt(view, eye, [0,0,0], [0,1,0]);

  // model: floating + rotation
  const model = mat4.create();
  mat4.translate(model, model, [0, Math.sin(t*1.5)*0.25, 0]); // melayang
  mat4.rotateY(model, model, t*0.7);
  mat4.rotateX(model, model, t*0.4);

  // normal matrix (mat3)
  const normalMat = mat3.create();
  mat3.normalFromMat4(normalMat, model);

  // projection
  const proj = getProjectionMatrix(canvas.width / canvas.height);

  // uniforms
  gl.useProgram(program);
  gl.uniformMatrix4fv(locs.uModel, false, model);
  gl.uniformMatrix4fv(locs.uView, false, view);
  gl.uniformMatrix4fv(locs.uProj, false, proj);
  gl.uniformMatrix3fv(locs.uNormalMat, false, normalMat);

  const lightPos = [4.0 * Math.cos(t*0.6), 3.0, 4.0 * Math.sin(t*0.6)];
  gl.uniform3fv(locs.uLightPos, lightPos);
  gl.uniform3fv(locs.uViewPos, eye);
  gl.uniform1f(locs.uLightIntensity, parseFloat(lint.value));
  gl.uniform1f(locs.uShininess, parseFloat(shin.value));
  gl.uniform1f(locs.uUseTex, texToggle.checked ? 1.0 : 0.0);
  gl.uniform3fv(locs.uBaseColor, [1.0, 0.92, 0.8]); // warm base

  // bind texture
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.uniform1i(locs.uAlbedo, 0);

  // draw
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clearColor(0.03,0.04,0.06,1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  gl.bindVertexArray(vao);
  gl.drawElements(gl.TRIANGLES, geo.indices.length, gl.UNSIGNED_SHORT, 0);
  gl.bindVertexArray(null);

  requestAnimationFrame(frame);
}
requestAnimationFrame(frame);

</script>
</body>
</html>
