<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebGL Walking Cube - Custom</title>
<style>
  body { margin:0; overflow:hidden; background:#aaa; }
  canvas { display:block; }
  #info { position:absolute; top:10px; left:10px; color:#000; font-family:sans-serif; }
</style>
</head>
<body>
<div id="info">
Use W/A/S/D to move the cube, Shift to run
</div>
<canvas id="glcanvas"></canvas>
<script>
const canvas = document.getElementById('glcanvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext('webgl2');
if(!gl) alert('WebGL2 not supported');

// ===== Shaders =====
const vs = `#version 300 es
in vec3 aPos;
in vec3 aColor;
uniform mat4 uMV;
uniform mat4 uP;
out vec3 vColor;
void main(){ gl_Position = uP * uMV * vec4(aPos,1.0); vColor = aColor; }`;
const fs = `#version 300 es
precision mediump float;
in vec3 vColor;
out vec4 outColor;
void main(){ outColor = vec4(vColor,1.0); }`;
function createShader(gl,type,src){
  const s=gl.createShader(type);
  gl.shaderSource(s,src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s));
  return s;
}
const prog = gl.createProgram();
gl.attachShader(prog,createShader(gl,gl.VERTEX_SHADER,vs));
gl.attachShader(prog,createShader(gl,gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
if(!gl.getProgramParameter(prog,gl.LINK_STATUS)) console.error(gl.getProgramInfoLog(prog));
gl.useProgram(prog);

// ===== Cube =====
const cubeV = new Float32Array([
  -0.5,-0.5,-0.5, 1,0,0,  0.5,-0.5,-0.5, 0,1,0,
  0.5,0.5,-0.5,0,0,1, -0.5,0.5,-0.5,1,1,0,
  -0.5,-0.5,0.5,0,1,1, 0.5,-0.5,0.5,1,0,1,
  0.5,0.5,0.5,1,1,1, -0.5,0.5,0.5,0,0,0
]);
const cubeI = new Uint16Array([
 0,1,2,0,2,3, 4,5,6,4,6,7,
 0,1,5,0,5,4, 1,2,6,1,6,5,
 2,3,7,2,7,6, 3,0,4,3,4,7
]);
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
gl.bufferData(gl.ARRAY_BUFFER,cubeV,gl.STATIC_DRAW);
const aPos = gl.getAttribLocation(prog,'aPos');
gl.vertexAttribPointer(aPos,3,gl.FLOAT,false,6*4,0);
gl.enableVertexAttribArray(aPos);
const aColor = gl.getAttribLocation(prog,'aColor');
gl.vertexAttribPointer(aColor,3,gl.FLOAT,false,6*4,3*4);
gl.enableVertexAttribArray(aColor);
const ebo = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ebo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,cubeI,gl.STATIC_DRAW);

// ===== Grid =====
let grid=[];
const size=50,div=50;
for(let i=0;i<=div;i++){
 let x=-size/2+i*(size/div);
 grid.push(x,0,-size/2,0,0,0,x,0,size/2,0,0,0);
 let z=-size/2+i*(size/div);
 grid.push(-size/2,0,z,0,0,0,size/2,0,z,0,0,0);
}
const gVBO=gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,gVBO);
gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(grid),gl.STATIC_DRAW);

// ===== Matrices =====
function perspective(fovy,aspect,n,f){ const f=1/Math.tan(fovy/2); const nf=1/(n-f);
return [f/aspect,0,0,0,0,f,0,0,0,0,(f+n)*nf,-1,0,0,2*f*n*nf,0]; }
function lookAt(e,c,u){
 const f=[c[0]-e[0],c[1]-e[1],c[2]-e[2]];
 const fl=Math.hypot(...f); f[0]/=fl; f[1]/=fl; f[2]/=fl;
 const s=[f[1]*u[2]-f[2]*u[1],f[2]*u[0]-f[0]*u[2],f[0]*u[1]-f[1]*u[0]];
 const sl=Math.hypot(...s); s[0]/=sl;s[1]/=sl;s[2]/=sl;
 const up=[s[1]*f[2]-s[2]*f[1],s[2]*f[0]-s[0]*f[2],s[0]*f[1]-s[1]*f[0]];
 return [
 s[0],up[0],-f[0],0,s[1],up[1],-f[1],0,s[2],up[2],-f[2],0,
 -(s[0]*e[0]+s[1]*e[1]+s[2]*e[2]),
 -(up[0]*e[0]+up[1]*e[1]+up[2]*e[2]),
 f[0]*e[0]+f[1]*e[1]+f[2]*e[2],1
]; }
function mul(a,b){const o=new Array(16).fill(0);for(let i=0;i<4;i++)for(let j=0;j<4;j++)for(let k=0;k<4;k++)o[i*4+j]+=a[i*4+k]*b[k*4+j];return o;}

// ===== Camera =====
let cam=[10,10,10],target=[0,0,0],up=[0,1,0];

// ===== Input =====
let cubePos=[0,0.5,0];
let keys=[0,0,0]; // forward/back/shift
document.addEventListener('keydown',e=>{
 if(e.key=='w') keys[0]=-1;
 if(e.key=='s') keys[0]=1;
 if(e.key=='a') keys[1]=-1;
 if(e.key=='d') keys[1]=1;
 if(e.key=='Shift') keys[2]=1;
});
document.addEventListener('keyup',e=>{
 if(e.key=='w'||e.key=='s') keys[0]=0;
 if(e.key=='a'||e.key=='d') keys[1]=0;
 if(e.key=='Shift') keys[2]=0;
});

// ===== Animation Loop =====
let last=0;
function render(t){
 t*=0.001;
 const dt=t-last;
 last=t;

 // Move cube
 const speed=keys[2]?5:2;
 cubePos[0]+=keys[1]*speed*dt;
 cubePos[2]+=keys[0]*speed*dt;

 // Camera follows cube
 const eye=[cam[0]+cubePos[0],cam[1],cam[2]+cubePos[2]];
 const P=perspective(Math.PI/4,canvas.width/canvas.height,0.1,100);
 const V=lookAt(eye,cubePos,up);

 // Cube rotation animation
 const angle=t*2;
 const cM=[Math.cos(angle),0,Math.sin(angle),0,0,1,0,0,-Math.sin(angle),0,Math.cos(angle),0,cubePos[0],cubePos[1],cubePos[2],1];
 const MV=mul(V,cM);

 gl.viewport(0,0,canvas.width,canvas.height);
 gl.clearColor(0.7,0.7,0.7,1);
 gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
 gl.enable(gl.DEPTH_TEST);

 // Draw cube
 gl.uniformMatrix4fv(gl.getUniformLocation(prog,'uMV'),false,new Float32Array(MV));
 gl.uniformMatrix4fv(gl.getUniformLocation(prog,'uP'),false,new Float32Array(P));
 gl.bindVertexArray(vao);
 gl.drawElements(gl.TRIANGLES,cubeI.length,gl.UNSIGNED_SHORT,0);

 // Draw grid
 gl.bindBuffer(gl.ARRAY_BUFFER,gVBO);
 gl.vertexAttribPointer(0,3,gl.FLOAT,false,6*4,0);
 gl.enableVertexAttribArray(0);
 gl.vertexAttribPointer(1,3,gl.FLOAT,false,6*4,3*4);
 gl.enableVertexAttribArray(1);
 gl.uniformMatrix4fv(gl.getUniformLocation(prog,'uMV'),false,new Float32Array(V));
 gl.drawArrays(gl.LINES,0,grid.length/6);

 requestAnimationFrame(render);
}
requestAnimationFrame(render);

window.addEventListener('resize',()=>{
 canvas.width=window.innerWidth;
 canvas.height=window.innerHeight;
});
</script>
</body>
</html>
