<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Lantai Keramik Putih + Cube Berputar</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; width:100vw; height:100vh; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script src="https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/gl-matrix-min.js"></script>
<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// ==================== SHADER ====================
const vsSource = `
attribute vec3 aPosition;
attribute vec2 aUV;
uniform mat4 uMVP;
varying vec2 vUV;
void main() {
  vUV = aUV * 50.0; // ulang tile
  gl_Position = uMVP * vec4(aPosition, 1.0);
}
`;

const fsSource = `
precision mediump float;
varying vec2 vUV;
void main() {
  vec2 uv = fract(vUV);
  float lineX = step(0.98, uv.x);
  float lineY = step(0.98, uv.y);
  float line = max(lineX, lineY);

  vec3 tileColor = vec3(1.0);  // putih
  vec3 lineColor = vec3(0.7);  // abu
  vec3 baseColor = mix(tileColor, lineColor, line);
  gl_FragColor = vec4(baseColor, 1.0);
}
`;

function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
  }
  return shader;
}
const vs = createShader(gl.VERTEX_SHADER, vsSource);
const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
gl.useProgram(program);

// ==================== GEOMETRI ====================
function makePlane(size=20) {
  return {
    pos: new Float32Array([
      -size,0,-size,   size,0,-size,   size,0, size,
      -size,0,-size,   size,0, size,  -size,0, size
    ]),
    uv: new Float32Array([
      0,0, 1,0, 1,1,
      0,0, 1,1, 0,1
    ])
  };
}

function makeCube(size=1) {
  let s = size/2;
  let positions = [
    -s,-s, s,  s,-s, s,  s, s, s,  -s, s, s,  // depan
    -s,-s,-s, -s, s,-s,  s, s,-s,   s,-s,-s,  // belakang
    -s, s,-s, -s, s, s,  s, s, s,   s, s,-s,  // atas
    -s,-s,-s,  s,-s,-s,  s,-s, s,  -s,-s, s,  // bawah
     s,-s,-s,  s, s,-s,  s, s, s,   s,-s, s,  // kanan
    -s,-s,-s, -s,-s, s, -s, s, s,  -s, s,-s   // kiri
  ];
  let uv = new Array(positions.length/3*2).fill(0);
  let indices = [];
  for (let i=0;i<6;i++) {
    let base = i*4;
    indices.push(base,base+1,base+2, base,base+2,base+3);
  }
  return {pos:new Float32Array(positions), uv:new Float32Array(uv), indices:new Uint16Array(indices)};
}

// ==================== BUFFER ====================
function createBuffer(data, loc, size) {
  let buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc, size, gl.FLOAT, false, 0, 0);
}

const aPos = gl.getAttribLocation(program, "aPosition");
const aUV  = gl.getAttribLocation(program, "aUV");
const uMVP = gl.getUniformLocation(program, "uMVP");

let plane = makePlane();
let planeVAO = gl.createVertexArray();
gl.bindVertexArray(planeVAO);
createBuffer(plane.pos, aPos, 3);
createBuffer(plane.uv, aUV, 2);

let cube = makeCube(2);
let cubeVAO = gl.createVertexArray();
gl.bindVertexArray(cubeVAO);
createBuffer(cube.pos, aPos, 3);
createBuffer(cube.uv, aUV, 2);
let ibo = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cube.indices, gl.STATIC_DRAW);

// ==================== CAMERA CONTROL ====================
let angleX=0, angleY=0;
let dragging=false,lastX,lastY;
canvas.addEventListener("mousedown",e=>{
  dragging=true;lastX=e.clientX;lastY=e.clientY;
});
canvas.addEventListener("mouseup",()=>dragging=false);
canvas.addEventListener("mousemove",e=>{
  if(!dragging)return;
  let dx=e.clientX-lastX, dy=e.clientY-lastY;
  angleX+=dx*0.01;
  angleY+=dy*0.01;
  lastX=e.clientX;lastY=e.clientY;
});

let camOffsetX=0, camOffsetY=5, camOffsetZ=10;
document.addEventListener("keydown",e=>{
  let step=0.5;
  if(e.key==="ArrowUp")    camOffsetY+=step;
  if(e.key==="ArrowDown")  camOffsetY-=step;
  if(e.key==="ArrowLeft")  camOffsetX-=step;
  if(e.key==="ArrowRight") camOffsetX+=step;
});

// ==================== RENDER LOOP ====================
function render(){
  gl.viewport(0,0,canvas.width,canvas.height);
  gl.clearColor(0.2,0.2,0.25,1);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

  let proj=mat4.create();
  mat4.perspective(proj, Math.PI/3, canvas.width/canvas.height, 0.1, 100.0);

  let eye=[camOffsetX+10*Math.sin(angleX), camOffsetY+10*Math.sin(angleY), camOffsetZ+10*Math.cos(angleX)];
  let view=mat4.create();
  mat4.lookAt(view, eye, [0,0,0], [0,1,0]);

  let vp=mat4.create();
  mat4.multiply(vp, proj, view);

  // ---- lantai ----
  let model=mat4.create();
  let mvp=mat4.create();
  mat4.multiply(mvp, vp, model);
  gl.bindVertexArray(planeVAO);
  gl.uniformMatrix4fv(uMVP,false,mvp);
  gl.drawArrays(gl.TRIANGLES,0,6);

  // ---- cube (rotasi otomatis) ----
  model=mat4.create();
  mat4.translate(model, model, [0,1,0]); // melayang
  let t = performance.now() * 0.001;
  mat4.rotateY(model, model, t);       // rotasi Y
  mat4.rotateX(model, model, t*0.7);   // rotasi X
  mvp=mat4.create();
  mat4.multiply(mvp, vp, model);
  gl.bindVertexArray(cubeVAO);
  gl.uniformMatrix4fv(uMVP,false,mvp);
  gl.drawElements(gl.TRIANGLES, cube.indices.length, gl.UNSIGNED_SHORT, 0);

  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
