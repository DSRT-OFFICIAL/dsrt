<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini 3D Engine Full Advanced</title>
<style>
body{margin:0;font-family:sans-serif;background:#111;color:#eee;display:flex;height:100vh;}
#tree{width:250px;background:#1a1a1a;overflow-y:auto;padding:10px;border-right:1px solid #444;}
#tree ul{list-style:none;padding-left:20px;}
#tree li{cursor:pointer;padding:2px;}
#tree li.selected{background:#444;}
#preview{flex:1;position:relative;}
canvas{width:100%;height:100%;display:block;touch-action:none;}
#gui{position:absolute;top:10px;right:10px;background:rgba(0,0,0,0.7);padding:10px;border-radius:6px;width:180px;}
#gui input{width:100%;margin-bottom:5px;}
</style>
</head>
<body>

<div id="tree">
<h3>Scene Hierarchy</h3>
<ul id="scene-tree"></ul>
</div>

<div id="preview">
<canvas id="glcanvas"></canvas>
<div id="gui">
<h4>Transform</h4>
<label>Pos X:<input type="number" id="posX" step="0.1"></label>
<label>Pos Y:<input type="number" id="posY" step="0.1"></label>
<label>Pos Z:<input type="number" id="posZ" step="0.1"></label>
<label>Rot Y:<input type="number" id="rotY" step="1"></label>
<label>Scale:<input type="number" id="scale" step="0.1" value="1"></label>
</div>
</div>

<script>
// ================= Core Classes =================
class Object3D{
  constructor(name){ 
    this.name=name; this.children=[]; 
    this.position=[0,0,0]; this.rotation=[0,0,0]; this.scale=1; 
    this.mesh=null; this.color=[Math.random(),Math.random(),Math.random(),1]; 
    this.highlight=false;
  }
  add(child){ this.children.push(child); }
}

// ================= Scene Graph =================
const SceneRoot = new Object3D("Scene");
const cube = new Object3D("Cube"); cube.mesh='cube'; cube.position=[0,0.5,0];
const floor = new Object3D("Floor"); floor.mesh='plane'; floor.position=[0,0,0]; floor.color=[0.5,0.5,0.5,1];
const sphere = new Object3D("Sphere"); sphere.mesh='cube'; sphere.position=[2,0.5,0];
const cone = new Object3D("Cone"); cone.mesh='cube'; cone.position=[-2,0.5,0];
const torus = new Object3D("Torus"); torus.mesh='cube'; torus.position=[0,0.5,-2];

const group2 = new Object3D("Group2"); group2.add(torus);
const group1 = new Object3D("Group1"); group1.add(sphere); group1.add(cone); group1.add(group2);

SceneRoot.add(cube); SceneRoot.add(group1); SceneRoot.add(floor);

// ================= WebGL Setup =================
const canvas=document.getElementById('glcanvas');
const gl=canvas.getContext('webgl');
canvas.width=canvas.clientWidth; canvas.height=canvas.clientHeight;
gl.enable(gl.DEPTH_TEST);
gl.clearColor(0.1,0.1,0.1,1);

const vertSrc=`attribute vec3 position;uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;void main(){gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`;
const fragSrc=`precision mediump float;uniform vec4 uColor;void main(){gl_FragColor=uColor;}`;

function compileShader(src,type){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s); if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(s)); return s; }

const vert=compileShader(vertSrc,gl.VERTEX_SHADER);
const frag=compileShader(fragSrc,gl.FRAGMENT_SHADER);
const prog=gl.createProgram();
gl.attachShader(prog,vert); gl.attachShader(prog,frag);
gl.linkProgram(prog); gl.useProgram(prog);

const posLoc=gl.getAttribLocation(prog,"position");
const uColorLoc=gl.getUniformLocation(prog,"uColor");
const uMV=gl.getUniformLocation(prog,"modelViewMatrix");
const uProj=gl.getUniformLocation(prog,"projectionMatrix");

// ================= Simple Geometries =================
function createCube(){ return new Float32Array([-0.5,-0.5,-0.5,0.5,-0.5,-0.5,0.5,0.5,-0.5,-0.5,0.5,-0.5,-0.5,-0.5,0.5,0.5,-0.5,0.5,0.5,0.5,0.5,-0.5,0.5,0.5]); }
function createPlane(){ return new Float32Array([-5,0,-5,5,0,-5,5,0,5,-5,0,5]); }

// ================= Matrix Helpers =================
function identity(){ return [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]; }
function multiplyMatrices(a,b){ let out=new Array(16).fill(0); for(let i=0;i<4;i++)for(let j=0;j<4;j++)for(let k=0;k<4;k++)out[i*4+j]+=a[i*4+k]*b[k*4+j]; return out; }
function translate(m,v){ let t=identity(); t[12]=v[0]; t[13]=v[1]; t[14]=v[2]; return multiplyMatrices(m,t);}
function scaleM(m,s){ let t=identity(); t[0]=t[5]=t[10]=s; return multiplyMatrices(m,t);}
function rotateY(m,a){ let c=Math.cos(a),s=Math.sin(a); let r=[c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1]; return multiplyMatrices(m,r);}
function perspective(fov,aspect,near,far){ const f=1/Math.tan(fov/2), nf=1/(near-far); return [f/aspect,0,0,0,0,f,0,0,0,0,(far+near)*nf,-1,0,0,2*far*near*nf,0]; }

// ================= Camera =================
let camAngleX=0, camAngleY=0, camDistance=10;
canvas.addEventListener('mousemove',e=>{ if(e.buttons===1){ camAngleX+=e.movementX*0.005; camAngleY+=e.movementY*0.005; } });
canvas.addEventListener('wheel',e=>{ camDistance*=e.deltaY>0?1.05:0.95; });

// ================= Draw =================
function drawObject(obj,parentMatrix){
  let mv=translate(identity(),obj.position); mv=rotateY(mv,obj.rotation[1]); mv=scaleM(mv,obj.scale);
  if(parentMatrix) mv=multiplyMatrices(parentMatrix,mv);

  if(obj.mesh){
    let buf=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,buf);
    let verts=obj.mesh==='cube'?createCube():createPlane();
    gl.bufferData(gl.ARRAY_BUFFER,verts,gl.STATIC_DRAW);
    gl.vertexAttribPointer(posLoc,3,gl.FLOAT,false,0,0); gl.enableVertexAttribArray(posLoc);
    let color=obj.highlight?[1,1,0,1]:obj.color;
    gl.uniform4fv(uColorLoc,color);
    gl.uniformMatrix4fv(uMV,false,new Float32Array(mv));
    const proj=perspective(Math.PI/4,canvas.width/canvas.height,0.1,100);
    let camMatrix=translate(identity(),[0,0,-camDistance]);
    camMatrix=rotateY(camMatrix,camAngleX); camMatrix=rotateY(camMatrix,camAngleY);
    gl.uniformMatrix4fv(uProj,false,new Float32Array(proj));
    gl.drawArrays(gl.TRIANGLE_STRIP,0,verts.length/3);
  }
  obj.children.forEach(c=>drawObject(c,mv));
}

// ================= Animation =================
let angle=0;
function animate(){
  requestAnimationFrame(animate);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  cube.rotation[1]=angle; sphere.rotation[1]=angle; torus.rotation[1]=angle;
  angle+=0.01;
  drawObject(SceneRoot,null);
}
animate();

// ================= Scene Tree GUI =================
const treeEl=document.getElementById('scene-tree');
let selectedObj=null;

function buildTree(obj,parentEl){
  let li=document.createElement('li'); li.textContent=obj.name; parentEl.appendChild(li);
  li.addEventListener('click',(e)=>{ e.stopPropagation(); selectedObj=obj; updateGUI(); updateTreeHighlight(); });
  if(obj.children.length>0){
    let ul=document.createElement('ul'); li.appendChild(ul);
    obj.children.forEach(c=>buildTree(c,ul));
  }
}
function updateTreeHighlight(){ const lis=treeEl.querySelectorAll('li'); lis.forEach(li=>li.classList.remove('selected')); if(selectedObj){ const matches=[...lis].filter(li=>li.textContent===selectedObj.name); matches.forEach(m=>m.classList.add('selected')); }}
buildTree(SceneRoot,treeEl);

// ================= GUI Transform =================
const posX=document.getElementById('posX'), posY=document.getElementById('posY'), posZ=document.getElementById('posZ'), rotY=document.getElementById('rotY'), scaleEl=document.getElementById('scale');
function updateGUI(){ if(!selectedObj) return; posX.value=selectedObj.position[0]; posY.value=selectedObj.position[1]; posZ.value=selectedObj.position[2]; rotY.value=selectedObj.rotation[1]*180/Math.PI; scaleEl.value=selectedObj.scale; }
[posX,posY,posZ,rotY,scaleEl].forEach(inp=>inp.addEventListener('input',()=>{ if(!selectedObj) return; selectedObj.position[0]=parseFloat(posX.value); selectedObj.position[1]=parseFloat(posY.value); selectedObj.position[2]=parseFloat(posZ.value); selectedObj.rotation[1]=parseFloat(rotY.value)*Math.PI/180; selectedObj.scale=parseFloat(scaleEl.value); }));
</script>
</body>
</html>
